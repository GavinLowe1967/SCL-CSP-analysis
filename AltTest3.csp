-- A test on an alt, on the assumption that channels follow the protocol.

-- Thread identities.  Thread AltThread will run the Alt; other threads will
-- act on channels.
datatype ThreadID = AltThread | T1 | T2 | T3 -- | T4

ChanThreads =  diff(ThreadID, {AltThread})

-- Identities of Alts
datatype AltID = Alt1 -- | Alt2

-- Identities of channels
datatype ChanID = c1 | c2

include "Types.csp"
include "Alt.csp"
include "Macros.csp"

-- The list of branches
branches =  <c1,c2>

instance A1 = Alt(Alt1, branches, ThreadID, ChanID)

-- Indices of branches
Index = {0 .. length(branches)-1}

-- Index of channel c in branches
index(c) = 
  let index1(c,cs) = if c == head(cs) then 0 else 1 + index1(c, tail(cs))
  within index1(c, branches)

----- The thread that runs the Alt repeatedly. 

Thread(me) = A1::beginAlt.me -> A1::endAlt.me?i.x -> Thread(me)

----- Process modelling the contract of a channel the Alt tries to receive on.

-- The contract is captured by three families of processes.  Most of the
-- contract is captured by Channel(c) processes, which: (1) treats the
-- registerIn and deregisterIn methods as atomic (i.e. observes the
-- linearization points); (2) models send methods by two events, sendX where a
-- thread registers its interest, and endSendX where a thread receives
-- notification that the send happens; (3) calls maybeReceive on the alt.
-- ChannelInterface(c) processes capture the linearization of item (1) in
-- terms of the corresponding calls and returns.  ChannelThreadInterface(t)
-- processes capture item (2) for thread t (and all channels).

-- registerIn.t.alt.c.index.res represents alt being registered by thread t
-- with channel c at index, and getting result res.  deregister.t.alt.c.index
-- represents thread t deregistering alt from c at index.

channel registerIn : ThreadID . AltID . ChanID . Index . RegisterInResult
channel deregisterIn : ThreadID . AltID . ChanID . Index

-- The calls to registerIn, deregisterIn are wrappped in events on channels
-- A1::beginRegisterIn, A1::endRegisterIn, A1::beginDeregisterIn and
-- A1::endDeregisterIn.  The following process describes the interface.

ChannelInterface(c) =
  A1::beginRegisterIn?t1?alt!c?index -> registerIn.t1.alt.c.index?result ->
    A1::endRegisterIn.t1.alt.c.result -> ChannelInterface(c)
  []
  A1::beginDeregisterIn?t1?alt!c?index -> deregisterIn.t1.alt.c.index ->
    A1::endDeregisterIn.t1.alt.c -> ChannelInterface(c)

-- beginSend.t.c.x represents thread t calling c!x.  sendX.t.c.x represents
-- that call being registered.  endSendX.t.c.x represents that the thread can
-- return.  endSend.t.c.x represents the call returning.
channel beginSend, sendX : ChanThreads . ChanID . Data
channel endSend, endSendX : ChanThreads . ChanID

-- IMPROVE names  sendX, endSendX

-- Interface between sending thread t and the channels.
ChannelThreadInterface(t) = 
  beginSend.t?c?x -> sendX.t.c.x -> endSendX.t.c -> endSend.t.c -> 
    ChannelThreadInterface(t)
  |~| STOP

-- Model of the contract of channel c.
Channel(c) = 
  sendX?t!c?x -> ChannelWait(c,t, x)
  []  
  registerIn?_?alt!c?index!RegisterInWaiting -> ChannelReg(c, alt, index)

-- Channel with thread t waiting to send x
ChannelWait(c, t, x) = 
  registerIn?_?alt!c?index!RegisterInSuccess.x -> endSendX.t.c -> Channel(c)

-- Channel with alt registered against index
ChannelReg(c, alt, index) = 
  DeregisterIn(c,alt,index); Channel(c)
  [] 
  sendX?t!c?x -> 
    -- call maybeReceive on the alt
    A1::beginMaybeReceive.t.index.x -> A1::endMaybeReceive.t?res ->
    if res then endSendX.t.c -> Channel(c)
    else PostMaybeReceive(c,alt,t,index,x)

-- Be deregistered by alt with index, then terminate.
DeregisterIn(c,alt,index) = 
  deregisterIn?_?alt'!c?index' -> Assert1(alt' == alt and index' == index)

-- Thread t channel has performed alt.maybeReceive(x,index), which failed.
-- The alt may still deregister with this.
PostMaybeReceive(c,alt,t,index,x) = 
  DeregisterIn(c,alt,index); ChannelWait(c, t, x) 
  []
  -- If a registerIn happens, then the deregisterIn isn't going to happen
  ChannelWait(c, t, x) 

----------------------------------

-- Combine the components of the channel contract. 

WrappedChannel(c) = 
  let syncSet = 
    {| registerIn.t1.alt.c, deregisterIn.t1.alt.c | 
         t1 <- ThreadID, alt <- AltID |} 
  within
  (Channel(c) [| syncSet |] ChannelInterface(c)) \ syncSet

Channels =
  let WrappedChans = ||| c <- ChanID @ WrappedChannel(c)
      ChannelThreadsInterface = ||| t <- ChanThreads @ ChannelThreadInterface(t)
      syncSet = {|sendX,endSendX|}
  within (WrappedChans [| syncSet |] ChannelThreadsInterface) \ syncSet 

alphaChannels = A1::ChannelInterface

--------- Construct system

System0 = Thread(AltThread) ||| Channels

System1 =  A1::runWithAndHide(System0) \ alphaChannels 

assert System1 :[divergence free] -- succeeds.

assert not System1 :[deadlock free]
-- Can deadlock if both channels could refuse to communicate.

System = System1 \ {|A1::spuriousWakeUp|} 

assert not System :[divergence free] -- diverges because of spurious wake ups

------ Specification for synchronisation linearisation.

-- Synchronisation between thread in Alt and channel, passing data value.
channel sync : ThreadID . ChanID . Data

-- Lineariser of thread in Alt.
AltLin(me) = 
  A1::beginAlt.me -> sync.me?c?x -> A1::endAlt.me.index(c).x -> AltLin(me)

-- Lineariser of thread sending on channel c.
ChanLin(c,t) = 
  beginSend.t!c?x -> sync.AltThread!c!x -> endSend.t.c -> ChanLin(c,t) 
  |~| STOP

ChanLins = ||| c <- ChanID, t <- ChanThreads @ ChanLin(c,t)

Spec = (AltLin(AltThread) [| {| sync.AltThread |} |] ChanLins) \ {| sync |}

assert Spec [T= System

assert Spec [F= System