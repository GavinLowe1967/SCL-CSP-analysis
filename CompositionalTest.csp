-- A test on the combination of an idealised alt and idealised channels. 

-- This file is expected to be included from a file that defines a specific
-- collection of channels.  More specifically: (1) a type ChanId; (2) a
-- consistent definition of branches; (3) IdealisedChans, defining the
-- channels, probably using the mkChan function; (4) processes ChanThread(t),
-- probably using mkChanThread; (5) ClientThreadInterface; (6) sets sendChans,
-- receiveChans, sendWithinChans, receiveWithinChans, closeChans and
-- clientInterface, as for CombinedSpec.

-- Thread identities.  Thread AltThread will run the Alt; other threads will
-- act on channels.
datatype ThreadID = AltThread | T1 | T2 -- | T3 -- | T4

ChanThreads =  diff(ThreadID, {AltThread})

-- -- Identities of channels
-- datatype ChanID = Chan0 | Chan1

include "Types.csp"

-- Identities of Alts
datatype AltID = Alt1

-- -- The list of branches in the alt
-- branches =  <InPortBranch.Chan0, OutPortBranch.Chan1>
-- -- branches =  <InPortBranch.Chan0, InPortBranch.Chan1>

size = length(branches)

Index = {0..size-1}

-- Create idealised channels

include "IdealisedChan.csp"

-- instance IC0 = IdealisedChan(size)

-- instance IC1 = IdealisedChan(size)

-- Create the idealised alt.

include "IdealisedAlt.csp"

-- Rename events of IdealisedChans to be consistent with A1

transparent normal, sbisim, diamond

compress(P) = normal(P)
-- compress(P) = sbisim(diamond(P))

-- Function to rename an idealised channel to be consistent with IdealisedAlt.
-- Unfortunately the FDR module system doesn't allow us to parameterise the
-- function by the instance, so we need to pass in the channels separately.
mkChan(
  IdealisedChannel, Chan,
  beginRegisterIn, endRegisterIn, beginRegisterOut, endRegisterOut,
  beginDeregisterIn, endDeregisterIn, beginDeregisterOut, endDeregisterOut,
  beginMaybeReceive, endMaybeReceive, beginMaybeSend, endMaybeSend,
  beginPortClosed, endPortClosed
) = 
  compress(IdealisedChannel)[[
    beginRegisterIn.t.Alt1 <- IdealisedAlt::beginRegisterIn.t.Chan,
    endRegisterIn.t.Alt1 <- IdealisedAlt::endRegisterIn.t.Chan,
    beginRegisterOut.t.Alt1 <- IdealisedAlt::beginRegisterOut.t.Chan,
    endRegisterOut.t.Alt1 <- IdealisedAlt::endRegisterOut.t.Chan,
    beginDeregisterIn.t.Alt1 <- IdealisedAlt::beginDeregisterIn.t.Chan,
    endDeregisterIn.t.Alt1 <- IdealisedAlt::endDeregisterIn.t.Chan,
    beginDeregisterOut.t.Alt1 <- IdealisedAlt::beginDeregisterOut.t.Chan,
    endDeregisterOut.t.Alt1 <- IdealisedAlt::endDeregisterOut.t.Chan,
    beginMaybeReceive.t.Alt1 <- IdealisedAlt::beginMaybeReceive.t,
    endMaybeReceive.t.Alt1 <- IdealisedAlt::endMaybeReceive.t,
    beginMaybeSend.t.Alt1 <- IdealisedAlt::beginMaybeSend.t,
    endMaybeSend.t.Alt1 <- IdealisedAlt::endMaybeSend.t,
    beginPortClosed.t.Alt1 <- IdealisedAlt::beginPortClosed.t,
    endPortClosed.t.Alt1 <- IdealisedAlt::endPortClosed.t
      | t <- ThreadID ]]

-- IdealisedChannel0 = mkChan(
--   IC0::IdealisedChannel, Chan0, 
--   IC0::beginRegisterIn, IC0::endRegisterIn, 
--   IC0::beginRegisterOut, IC0::endRegisterOut,
--   IC0::beginDeregisterIn, IC0::endDeregisterIn, 
--   IC0::beginDeregisterOut, IC0::endDeregisterOut,
--   IC0::beginMaybeReceive, IC0::endMaybeReceive, 
--   IC0::beginMaybeSend, IC0::endMaybeSend,
--   IC0::beginPortClosed, IC0::endPortClosed)

-- IdealisedChannel1 = mkChan(
--   IC1::IdealisedChannel, Chan1, 
--   IC1::beginRegisterIn, IC1::endRegisterIn, 
--   IC1::beginRegisterOut, IC1::endRegisterOut,
--   IC1::beginDeregisterIn, IC1::endDeregisterIn, 
--   IC1::beginDeregisterOut, IC1::endDeregisterOut,
--   IC1::beginMaybeReceive, IC1::endMaybeReceive, 
--   IC1::beginMaybeSend, IC1::endMaybeSend,
--   IC1::beginPortClosed, IC1::endPortClosed)

-- The combination of the idealised channels and alts.
System00 = 
  IdealisedChans -- (IdealisedChannel0 ||| IdealisedChannel1) 
  [| IdealisedAlt::ChannelInterface |] 
  -- compress(IdealisedAlt::IdealisedAltSpec)
  sbisim(diamond(IdealisedAlt::IdealisedAlt))

System0 = System00 \ IdealisedAlt::ChannelInterface

------ Threads that interact with the system

-- The alt thread; can allow arbitrary events from the interface.
TheAltThread = RUN(IdealisedAlt::altInterface(AltThread))

-- We define channel threads in a way that allows for fairly concise
-- definitions, overcoming shortcomings in the FDR module system.  We define
-- it in term of a set "pairs" of pairs (begins, ends), where begins
-- represents begin events on a particular channel, and end represents end
-- events on the same channel.  The process repeatedly performs a begin event
-- and then an end event for the same channel.  Note that the channel itself
-- ensures the begin and end events match.  This simply ensures that the
-- thread doesn't call operations on two channels concurrently.
mkChanThread(pairs) = 
  [] (begins, ends) <- pairs @  
   [] e: begins @ e -> [] e': ends @ e' -> mkChanThread(pairs) 

-- -- A channel thread for IC0 and IC1
-- ChanThread(me) = mkChanThread({
--   (IC0::clientBegins(me), IC0::clientEnds(me)),
--   (IC1::clientBegins(me), IC1::clientEnds(me)) 
-- }) 


AllThreads = TheAltThread ||| (||| t <- ChanThreads @ ChanThread(t))

ThreadInterface = Union({ 
  IdealisedAlt::AltInterface, ClientThreadInterface
  -- IC0::ClientInterface, IC1::ClientInterface
})

System = System0 [| ThreadInterface |]  AllThreads

-- Check no Error events happen.

-- Alphabet of System
Alpha = Union({ ThreadInterface, {| IdealisedAlt::spuriousWakeup |} })

assert CHAOS(Alpha) [T= System

------- Synchronisation linearisation

-- Include the definitions needed for CombinedSpec.csp

beginAlt = IdealisedAlt::beginAlt
endAlt = IdealisedAlt::endAlt

-- -- Definitions of the ChanIDs and (CSP) channels used for beginning and ending
-- -- operations.
-- sendChans = {
--   (Chan0, IC0::beginSend, IC0::endSend), (Chan1, IC1::beginSend, IC1::endSend) }
-- receiveChans = {
--   (Chan0, IC0::beginReceive, IC0::endReceive), 
--   (Chan1, IC1::beginReceive, IC1::endReceive) }
-- sendWithinChans = {
--   (Chan0, IC0::beginSendWithin, IC0::endSendWithin), 
--   (Chan1, IC1::beginSendWithin, IC1::endSendWithin) } 
-- receiveWithinChans = {
--   (Chan0, IC0::beginReceiveWithin, IC0::endReceiveWithin), 
--   (Chan1, IC1::beginReceiveWithin, IC1::endReceiveWithin) }
-- closeChans = {
--   (Chan0, IC0::beginClose, IC0::endClose), 
--   (Chan1, IC1::beginClose, IC1::endClose) }

-- clientInterface(me) = union(IC0::clientInterface(me), IC1::clientInterface(me))

include "CombinedSpec.csp"

-- Main checks

assert System :[divergence free]

assert Spec [T= System \ {|IdealisedAlt::spuriousWakeup|}

assert Spec [F= System \ {|IdealisedAlt::spuriousWakeup|}

-- For FD check, we need to keep spuriousWakeups visible.

Spec1 = Spec ||| CHAOS({|IdealisedAlt::spuriousWakeup|})

-- Following replaced by lazy abstraction test, which is more efficient.
-- assert Spec1 [T= System
-- assert Spec1 [F= System 
-- assert Spec1 [FD= System 

-- Tests below are for timing purposes

-- assert Spec [FD= STOP -- ~9.0s

-- assert STOP [FD= System -- ~10.4s