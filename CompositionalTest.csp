-- A test on the combination of an idealised alt and idealised channels. 

-- Thread identities.  Thread AltThread will run the Alt; other threads will
-- act on channels.
datatype ThreadID = AltThread | T1 | T2  | T3 -- | T4

ChanThreads =  diff(ThreadID, {AltThread})

-- Identities of channels
datatype ChanID = Chan0 | Chan1

include "Types.csp"

-- Identities of Alts
datatype AltID = Alt1

-- The list of branches in the alt
branches =  <InPortBranch.Chan0, OutPortBranch.Chan1>
-- branches =  <InPortBranch.Chan0, InPortBranch.Chan1>

size = length(branches)

Index = {0..size-1}

-- Create idealised channels

include "IdealisedChan.csp"

instance IC0 = IdealisedChan(size)

instance IC1 = IdealisedChan(size)

-- Create the idealised alt.

--include "Alt.csp"

include "IdealisedAlt.csp"

-- Rename events of IdealisedChans to be consistent with A1

transparent normal, sbisim, diamond

compress(P) = normal(P)
-- compress(P) = sbisim(diamond(P))

IdealisedChannel0 =
  compress(IC0::ChannelSpec)[[
    IC0::beginRegisterIn.t.Alt1 <- IdealisedAlt::beginRegisterIn.t.Chan0,
    IC0::endRegisterIn.t.Alt1 <- IdealisedAlt::endRegisterIn.t.Chan0,
    IC0::beginRegisterOut.t.Alt1 <- IdealisedAlt::beginRegisterOut.t.Chan0,
    IC0::endRegisterOut.t.Alt1 <- IdealisedAlt::endRegisterOut.t.Chan0,
    IC0::beginDeregisterIn.t.Alt1 <- IdealisedAlt::beginDeregisterIn.t.Chan0,
    IC0::endDeregisterIn.t.Alt1 <- IdealisedAlt::endDeregisterIn.t.Chan0,
    IC0::beginDeregisterOut.t.Alt1 <- IdealisedAlt::beginDeregisterOut.t.Chan0,
    IC0::endDeregisterOut.t.Alt1 <- IdealisedAlt::endDeregisterOut.t.Chan0,
    IC0::beginMaybeReceive.t.Alt1 <- IdealisedAlt::beginMaybeReceive.t,
    IC0::endMaybeReceive.t.Alt1 <- IdealisedAlt::endMaybeReceive.t,
    IC0::beginMaybeSend.t.Alt1 <- IdealisedAlt::beginMaybeSend.t,
    IC0::endMaybeSend.t.Alt1 <- IdealisedAlt::endMaybeSend.t,
    IC0::beginPortClosed.t.Alt1 <- IdealisedAlt::beginPortClosed.t,
    IC0::endPortClosed.t.Alt1 <- IdealisedAlt::endPortClosed.t
      | t <- ThreadID ]]

IdealisedChannel1 =
  compress(IC1::ChannelSpec)[[
    IC1::beginRegisterIn.t.Alt1 <- IdealisedAlt::beginRegisterIn.t.Chan1,
    IC1::endRegisterIn.t.Alt1 <- IdealisedAlt::endRegisterIn.t.Chan1,
    IC1::beginRegisterOut.t.Alt1 <- IdealisedAlt::beginRegisterOut.t.Chan1,
    IC1::endRegisterOut.t.Alt1 <- IdealisedAlt::endRegisterOut.t.Chan1,
    IC1::beginDeregisterIn.t.Alt1 <- IdealisedAlt::beginDeregisterIn.t.Chan1,
    IC1::endDeregisterIn.t.Alt1 <- IdealisedAlt::endDeregisterIn.t.Chan1,
    IC1::beginDeregisterOut.t.Alt1 <- IdealisedAlt::beginDeregisterOut.t.Chan1,
    IC1::endDeregisterOut.t.Alt1 <- IdealisedAlt::endDeregisterOut.t.Chan1,
    IC1::beginMaybeReceive.t.Alt1 <- IdealisedAlt::beginMaybeReceive.t,
    IC1::endMaybeReceive.t.Alt1 <- IdealisedAlt::endMaybeReceive.t,
    IC1::beginMaybeSend.t.Alt1 <- IdealisedAlt::beginMaybeSend.t,
    IC1::endMaybeSend.t.Alt1 <- IdealisedAlt::endMaybeSend.t,
    IC1::beginPortClosed.t.Alt1 <- IdealisedAlt::beginPortClosed.t,
    IC1::endPortClosed.t.Alt1 <- IdealisedAlt::endPortClosed.t
      | t <- ThreadID ]]

-- The combination of the idealised channels and alts.
System00 = 
  (IdealisedChannel0 ||| IdealisedChannel1) 
  [| IdealisedAlt::ChannelInterface |] 
  -- compress(IdealisedAlt::IdealisedAltSpec)
  sbisim(diamond(IdealisedAlt::IdealisedAltSpec))

System0 = System00 \ IdealisedAlt::ChannelInterface

------ Threads that interact with the system

-- The alt thread; can allow arbitrary events from the interface.
TheAltThread = RUN(IdealisedAlt::altInterface(AltThread))

-- We assume that channel threads alernate between the different operations.
ChanThread(me) = 
  IC0::beginSend.me?x -> IC0::endSend.me?res -> ChanThread(me)
  []
  IC1::beginSend.me?x -> IC1::endSend.me?res -> ChanThread(me)
  []
  IC0::beginReceive.me -> IC0::endReceive.me?res -> ChanThread(me)
  []
  IC1::beginReceive.me -> IC1::endReceive.me?res -> ChanThread(me)
  []
  IC0::beginSendWithin.me?x -> IC0::endSendWithin.me?res -> ChanThread(me)
  []
  IC1::beginSendWithin.me?x -> IC1::endSendWithin.me?res -> ChanThread(me)
  []
  IC0::beginReceiveWithin.me -> IC0::endReceiveWithin.me?res -> ChanThread(me)
  []
  IC1::beginReceiveWithin.me -> IC1::endReceiveWithin.me?res -> ChanThread(me)
  []
  IC0::beginClose.me -> IC0::endClose.me -> ChanThread(me)
  []
  IC1::beginClose.me -> IC1::endClose.me -> ChanThread(me)

AllThreads = TheAltThread ||| (||| t <- ChanThreads @ ChanThread(t))

ThreadInterface = Union({ 
  IdealisedAlt::AltInterface, IC0::ClientInterface, IC1::ClientInterface
})

System = System0 [| ThreadInterface |]  AllThreads

-- Check no Error events happen.

-- Alphabet of System
Alpha = Union({ ThreadInterface, {| IdealisedAlt::spuriousWakeup |} })

assert CHAOS(Alpha) [T= System

------- Synchronisation linearisation

-- Include the definitions needed for CombinedSpec.csp

beginAlt = IdealisedAlt::beginAlt
endAlt = IdealisedAlt::endAlt

-- Definitions of the ChanIDs and (CSP) channels used for beginning and ending
-- operations.
sendChans = {
  (Chan0, IC0::beginSend, IC0::endSend), (Chan1, IC1::beginSend, IC1::endSend) }
receiveChans = {
  (Chan0, IC0::beginReceive, IC0::endReceive), 
  (Chan1, IC1::beginReceive, IC1::endReceive) }
sendWithinChans = {
  (Chan0, IC0::beginSendWithin, IC0::endSendWithin), 
  (Chan1, IC1::beginSendWithin, IC1::endSendWithin) } 
receiveWithinChans = {
  (Chan0, IC0::beginReceiveWithin, IC0::endReceiveWithin), 
  (Chan1, IC1::beginReceiveWithin, IC1::endReceiveWithin) }
closeChans = {
  (Chan0, IC0::beginClose, IC0::endClose), 
  (Chan1, IC1::beginClose, IC1::endClose) }

clientInterface(me) = union(IC0::clientInterface(me), IC1::clientInterface(me))

include "CombinedSpec.csp"

-- Main checks

assert System :[divergence free]

assert Spec [T= System \ {|IdealisedAlt::spuriousWakeup|}

assert Spec [F= System \ {|IdealisedAlt::spuriousWakeup|}

-- For FD check, we need to keep spuriousWakeups visible.

Spec1 = Spec ||| CHAOS({|IdealisedAlt::spuriousWakeup|})

-- Following replaced by lazy abstraction test, which is more efficient.
-- assert Spec1 [T= System
-- assert Spec1 [F= System 
-- assert Spec1 [FD= System 

-- Tests below are for timing purposes

-- assert Spec [FD= STOP -- ~9.0s

-- assert STOP [FD= System -- ~10.4s