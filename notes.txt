Variable.csp: model of a variable

MonitorCondition.csp: blocks timeouts when another thread has the lock

MonitorCondition1.csp: allows timeouts when another thread has the lock

SyncChanV1.csp: corresponds to version used in course 

SyncChan1.csp: corresponds to SyncChanXXX.scala; receiver always resets
receviersWaiting



With the definition (as in SCL)

  def receiveWithinNanos(nanos: Long): Option[A] = lock.mutex{
    val deadline = nanoTime+nanos
    checkOpen
    // Try to receive from an alt first
    var result = tryAltSend; var timeout = false
    while(result.isEmpty && !full && !timeout){
      // Have to wait
      receiversWaiting += 1
      timeout = !slotFull.awaitNanos(deadline-nanoTime)
      checkOpen
      if(!timeout && !full) result = tryAltSend
    }
// FIXME: what if full here? 
    if(timeout){ 
      receiversWaiting -= 1 // Change, 14/02/2023
      assert(nanoTime-deadline >= 0); None
    }
    else result match{
      case Some(x) => Some(x)
      case None => 
        assert(full)
        Some(completeReceive)   // clear slot, signal and return result
    }
  }

it's possible that (1) a waiting thread T2 times out; (2) another thread finds
receiversWaiting = 1, so signals and decrements receiversWaiting; (3) T2 finds
receiversWaiting = 0, which is an error.


τ, τ, τ, beginReceiveWithin.T2, τ, τ, beginSend.T1.A, c::acquire.T2,
c::getFull.T2.false, c::getReceiversWaiting.T2.0, τ,
c::setReceiversWaiting.T2.1, c::timedAwait.T2.c::SlotFull,
(1) c::timedAwake.T2.c::SlotFull.false, τ, τ, c::acquire.T1, c::getFull.T1.false,
c::setValue.T1.A, c::setFull.T1.true, (2) c::getReceiversWaiting.T1.1,
c::signal.T1.c::SlotFull.T1, c::getReceiversWaiting.T1.1,
c::setReceiversWaiting.T1.0, c::await.T1.c::Continue, c::acquire.T2,
(3) c::getReceiversWaiting.T2.0, τ 

This is SyncChanV1.csp

----------

  result match{
    case Some(x) => Some(x)
    case None =>
      if(full) Some(completeReceive)
      else{ 
        assert(timeout); receiversWaiting -= 1
        assert(nanoTime-deadline >= 0); None
      }

No, that doesn't work, as the signalling thread could have decremented
receiversWaiting, another thread could have taken the value, and then this
thread could run and try decrementing receiversWaiting. 

How about the waiting thread always decrementing receiversWaiting when it is
awoken.  Thus the count includes receivers that have been awoken, or
timed out.  A sender signals only after setting full.  A receiver that
receives a signal will decrement receiversWaiting and test full.  If another
thread has taken the value, it might wait again.   
