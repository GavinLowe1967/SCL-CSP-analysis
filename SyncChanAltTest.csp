-- Test upon SyncChan

datatype ThreadID = T1 | T2  | T3 -- | T4
datatype AltID = Alt1 -- | Alt2

include "Types.csp"
include "SyncChanAlt.csp"

MaxIndex = 2

Index = {0 .. MaxIndex-1}

-- We'll test a single channel
instance c = SyncChan(ThreadID, AltID, Data, MaxIndex)

-- Successfully receive from Alt.
channel endAltReceive: ThreadID . AltID . Data

-- Thread with identity me: it either sends or receives, or interacts with the
-- channel as an alt, or does nothing.
Thread(me) = 
  c::beginSend.me?x -> c::endSend.me -> Thread(me)
  |~|
  c::beginReceive.me -> c::endReceive.me?x -> Thread(me)
  |~|
  c::beginSendWithin.me?x -> c::endSendWithin.me?b -> Thread(me)
  |~|
  c::beginReceiveWithin.me -> c::endReceiveWithin.me?ox -> Thread(me)
  |~|
  -- Alts, from regitration to the end of the interaction
  c::beginRegisterIn.me?alt?index -> (
    -- Wait for the alt interaction to end
    endAltReceive.me.alt?_ -> Thread(me) 
    [] c::endDeregisterIn.me.alt -> Thread(me)
  )
  |~| 
  STOP

-- Note: we need to include interactions where the thread is in the Alt above:
-- otherwise, the same thread could take both the role of the channel thread
-- and the alt thread, which would lead to it synchronising with itself; but
-- this is not allowed by the specification.

-- IMPROVE: do we need registration here? 

Threads = ||| t <- ThreadID @ Thread(t)

-- Events of Threads corresponding to being the Alt thread. 
threadAltEvents = 
  {| c::beginRegisterIn,  c::endDeregisterIn, endAltReceive |}

-- Alphabet of Threads.
alphaThreads = 
  union( Union({ c::threadInterface(t) | t <- ThreadID }), threadAltEvents )

-- A regulator to ensure multiple threads don't try to register an alt.
Reg = c::beginRegisterIn?t?alt?index -> Reg'(t,alt)
-- t is registering with alt.  Wait until either (1) that attempt succeeds,
-- (2) t deregisters alt, or (3) a call back succeeds.
Reg'(t,alt) = 
  c::endRegisterIn.t.alt.RegisterInSuccess?_ -> Reg
  []
  c::endDeregisterIn.t.alt -> Reg
  []
  c::endMaybeReceive?t'!alt.true -> Reg

-- Alphabet of Reg.  All are synchronisations with threads.
alphaReg = union(
  {| c::beginRegisterIn, c::endDeregisterIn |}, 
  {| c::endRegisterIn.t.a.RegisterInSuccess, c::endMaybeReceive.t.a.true | 
       t <- ThreadID, a <- AltID |}
) 

-- Process modelling the contract of an Alt.  This mediates between the thread
-- running the Alt, and callbacks from threads at the other end of a channel.

-- The Alt registers with the channel
AltReg(alt) = 
  |~| index : Index @
    c::beginRegisterIn?t!alt.index -> c::endRegisterIn.t.alt?rir -> 
    AltReg1(alt, t, index, rir)

-- The registration was successful, so the Alt returns.
AltReg1(alt, t, _, RegisterInSuccess.x) = endAltReceive.t.alt.x -> AltReg(alt)

-- Registering unsuccessful.  Wait for successful callback then end; or decide
-- to deregister.
AltReg1(alt, t, index, RegisterInWaiting) = 
  c::beginMaybeReceive?t1!alt.index?x -> (
    c::endMaybeReceive.t1.alt!true -> endAltReceive.t.alt.x -> AltReg(alt)
    [> c::beginDeregisterIn.t.alt.index -> AltReg2(alt, t, t1)
  )
  [>
  c::beginDeregisterIn.t.alt.index -> (
    c::endDeregisterIn.t.alt -> AltReg(alt)
    [] c::beginMaybeReceive?t1!alt?x -> AltReg2(alt, t, t1)
  )

-- Thread t is deregistering with alt; but t1 is attempting a callback.
AltReg2(alt, t, t1) = 
  c::endMaybeReceive.t1.alt!false -> c::endDeregisterIn.t.alt -> AltReg(alt)
  []
  c::endDeregisterIn.t.alt -> c::endMaybeReceive.t1.alt!false -> AltReg(alt)

Alts = ||| alt : AltID @ AltReg(alt)

--------------- Put system together

-- System ignoring the channel
System0 = 
  -- Synchronisations between Alts and either Threads or Reg.
  let AltsSync = union( alphaReg, threadAltEvents ) within
  ((Threads [alphaThreads||alphaReg] Reg) [|AltsSync|] Alts) 

System = 
  c::runWithAndHide(System0) 
  \ {| c::beginMaybeReceive, c::endMaybeReceive, c::endRegisterIn, 
       c::endDeregisterIn, c::beginDeregisterIn |}
-- Note: we keep visible the interface events an alt presents to a channel,
-- and beginRegisterIn and endAltReceive events.

assert System  :[divergence free]

-- Specification of synchronisation linearisation.

-- sync.t1.t2.x represents sender t1 and receiver t2 synchronising on the
-- sending of x.
channel sync : ThreadID . ThreadID . Data

-- A linearizer for thread me.
Linearizer(me) = 
  c::beginSend.me?x ->    -- Lin1(me, x) 
     sync.me?other!x -> c::endSend.me -> Linearizer(me)
  |~|
  c::beginReceive.me -> sync?other!me?x -> c::endReceive.me.x -> Linearizer(me)
  |~|
  c::beginSendWithin.me?x -> 
    (sync.me?other!x -> c::endSendWithin.me.true -> Linearizer(me)
     [> c::endSendWithin.me.false -> Linearizer(me))
  |~|
  c::beginReceiveWithin.me ->
    (sync?other!me?x -> c::endReceiveWithin.me.c::Some.x -> Linearizer(me)
     [> c::endReceiveWithin.me.(c::None) -> Linearizer(me))
  |~| 
  -- Alts
  c::beginRegisterIn.me?alt?_ -> (
    sync?other!me?x -> endAltReceive.me.alt.x -> Linearizer(me)
    [> Linearizer(me) -- offer withdrawn
  )
  |~|
  STOP

  
-- Alphabet of Linearizer(t)
alphaLin(t) = union( 
  c::threadInterface(t),
  {| c::beginRegisterIn.t, endAltReceive.t, sync.t.other, sync.other.t | 
       other <- diff(ThreadID,{t}) |}
)

  -- {| c::beginSend.t, c::endSend.t, c::beginReceive.t, c::endReceive.t, 
  --    c::beginSendWithin.t, c::endSendWithin.t,
  --    c::beginReceiveWithin.t, c::endReceiveWithin.t, 
  --    c::beginRegisterIn.t, endAltReceive.t, c::beginDeregisterIn.t,
  --    sync.t.other, sync.other.t | 
  --      other <- diff(ThreadID,{t}) |} 

-- Specification of synchronisation linearisation.
Spec = (|| t <- ThreadID @ [alphaLin(t)] Linearizer(t)) \ {| sync|}

assert Spec [T= System
assert Spec [F= System 