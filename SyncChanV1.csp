-- A module representing a synchronous channel.  This version does not include
-- interactions with Alts or closing of channels.
module SyncChan(ThreadID, Data)
  include "Variable.csp"

  -- The value variable: the current or previous value.
  channel getValue, setValue: ThreadID.Data
  Value = Var(head(seq(Data)), getValue, setValue)  

  -- The full variable: is the current value of value valid?
  channel getFull, setFull: ThreadID.Bool
  Full = Var(false, getFull, setFull)

  -- Number of threads
  N = card(ThreadID)

  -- The receiversWaiting variable
  channel getReceiversWaiting, setReceiversWaiting : ThreadID.{0..N}
  ReceiversWaiting = Var(0, getReceiversWaiting, setReceiversWaiting)

  -- Monitor and conditions
  datatype ConditionID = SlotFull | Continue | SlotEmptied

  include "MonitorCondition.csp"

  -- Assertion macros
  Assert(b, P) = if b then P else DIV
  Assert1(b) = Assert(b, SKIP)

  -------- Sending

  -- slotEmptied.await(!full)
  Send1(me, x) = 
    getFull.me?f -> 
    if f then MonitorCondition::Await(me, SlotEmptied); Send1(me, x) 
    else Send2(me, x)

  -- value = x; full = true 
  Send2(me, x) = setValue.me.x -> setFull.me.true -> CompleteSend(me, x)

  -- maybeSignalToReceiver:
  -- if(receiversWaiting > 0){ slotFull.signal(); receiversWaiting -= 1 }
  MaybeSignalToReceiver(me) = 
    getReceiversWaiting.me?r ->
    if r > 0 then 
      MonitorCondition::Signal(me, SlotFull); getReceiversWaiting.me?r1 -> 
      Assert1(r1 == r); setReceiversWaiting.me.r-1 -> SKIP
    else SKIP

  -- completeSend: maybeSignalToReceiver; continue.await(); release lock
  CompleteSend(me, x) = 
    MaybeSignalToReceiver(me);
    MonitorCondition::Await(me, Continue); 
    MonitorCondition::Unlock(me)

  -- Timed sending

  -- val timeout = !slotEmptied.awaitNanos(nanos, !full || isClosed)
  SendWithin1(me, x, cont) = 
    getFull.me?f -> 
    if not f then SendWithin2(me, x, cont, false)
    else 
      let cont1(b) = -- b if not timeout
        if b then SendWithin1(me, x, cont) 
        else getFull.me?f -> SendWithin2(me, x, cont, f)
      within MonitorCondition::TimedAwait(me, SlotEmptied, cont1)

  -- if(timeout) false 
  -- else{ assert(!full); value = x; full = true    // deposit my value
  --       maybeSignalToReceiver; ... }
  SendWithin2(me, x, cont, timeout) = 
    if(timeout) then MonitorCondition::Unlock(me); cont(false)
    else
      getFull.me?f -> Assert1(not f); 
      setValue.me.x -> setFull.me.true -> MaybeSignalToReceiver(me); 
      SendWithin3(me, x, cont)
  
  -- val success = continue.awaitNanos(deadline-nanoTime)
  SendWithin3(me, x, cont) = 
    let cont1(success) = 
          if success then MonitorCondition::Unlock(me); cont(true)
          else SendWithin4(me, x, cont)
    within MonitorCondition::TimedAwait(me, Continue, cont1)
  
  -- Case of no corresponding receiver
  -- assert(full && value == x); full = false; slotEmptied.signal(); false
  SendWithin4(me, x, cont) = 
    getFull.me?f -> getValue.me?x1 -> Assert1(f and x == x1);
    setFull.me.false -> MonitorCondition::Signal(me, SlotEmptied);
    MonitorCondition::Unlock(me); cont(false)

  -------- Receiving

  -- while(!full){ receiversWaiting += 1; slotFull.await() }
  Receive1(me, cont) = 
    getFull.me?f ->
    if not(f) then
      getReceiversWaiting.me?r -> 
      Assert(r < N, setReceiversWaiting.me.r+1 -> MonitorCondition::Await(me, SlotFull)); 
      Receive1(me, cont)
    else Receive2(me, cont)

  -- assert(full); 
  Receive2(me, cont) =
    getFull.me?f -> Assert1(f); CompleteReceive(me, cont)

  -- completeReceive: full = false; continue.signal(); slotEmptied.signal();
  -- unlock and return value
  CompleteReceive(me, cont) = 
    setFull.me.false -> 
    MonitorCondition::Signal(me, Continue); MonitorCondition::Signal(me, SlotEmptied);
    getValue.me?v -> (MonitorCondition::Unlock(me); cont(v))

  -- var timeout = false
  -- while(!full && !timeout){
  --   receiversWaiting += 1; timeout = !slotFull.awaintNanos(...)
  -- }
  ReceiveWithin1(me, cont) = 
    getFull.me?f ->
    if not(f) then
      getReceiversWaiting.me?r -> 
      Assert(r < N, setReceiversWaiting.me.r+1 -> SKIP);
      let cont1(b) = -- b if not timedout
      	if b then ReceiveWithin1(me, cont) 
        else ReceiveWithinTimeout(me, cont)
      within MonitorCondition::TimedAwait(me, SlotFull, cont1)
    else ReceiveWithinFull(me, cont)

  -- if(timeout){ receiversWaiting -= 1; None }
  ReceiveWithinTimeout(me, cont) = 
    getReceiversWaiting.me?rw ->
    Assert(rw > 0, setReceiversWaiting.me.rw-1 -> SKIP);
    MonitorCondition::Unlock(me); cont(None)

  -- assert(full); Some(completeReceive)
  ReceiveWithinFull(me, cont) = 
    getFull.me?f -> Assert1(f);
    CompleteReceive(me, \ v @ cont(Some.v))

  ---------- All variables

  Variables = Full ||| Value ||| ReceiversWaiting

  varEvents = 
    {| getFull, setFull, getValue, setValue, 
       getReceiversWaiting, setReceiversWaiting |}

  -- All internal events
  events = union(varEvents, MonitorCondition::events)

exports
  datatype Option = None | Some.Data

  -- Thread me sends x
  Send(me, x) = MonitorCondition::Lock(me); Send1(me, x)

  -- Thread me receives value, and applies cont to it.
  Receive :: (ThreadID, (Data) -> Proc) -> Proc
  Receive(me, cont) = MonitorCondition::Lock(me); Receive1(me, cont)

  -- Thread me does sendWithin(_)(x), and applies cont to it.
  SendWithin :: (ThreadID, Data, (Bool) -> Proc) -> Proc
  SendWithin(me, x, cont) = MonitorCondition::Lock(me); SendWithin1(me, x, cont)

  -- Thread me does receiveWithin(_) with continuation cont. 
  ReceiveWithin :: (ThreadID, (Option) -> Proc) -> Proc
  ReceiveWithin(me, cont) = MonitorCondition::Lock(me); ReceiveWithin1(me, cont)

  -- Run P with this channel
  runWith(P) = 
    let P1 = P [| varEvents |] Variables
    within MonitorCondition::runWith(P1)

  -- Run P with this channel, and hide internals
  runWithAndHide(P) = runWith(P) \ events

endmodule