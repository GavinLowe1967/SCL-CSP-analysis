
\subsection{Expressions}

We show that for every expression~$e$ in the script,
\begin{eqnarray*}
f(\eval \rho ~ e) & = \eval (f \after \rho) e .
\end{eqnarray*}

\framebox{\ldots}

Note:
\begin{eqnarray*}
\eval \rho ~(g(e)) & = & (\eval \rho ~g) (\eval \rho~ e) \\
\eval \rho ~(\lambda x \spot e) & = & 
  \lambda z \spot \eval (\rho \oplus \set{x \mapsto z})~ e.
\end{eqnarray*}


Case $e = t$, i.e.~the name of the distinguished type ...


We now consider process expressions.

\begin{itemize}
\item Basic processes $STOP$, $SKIP$, $div$: these are all trivial. 

\item Prefixing.  Consider $e_c ~ f_1 \ldots f_n \then P$, where $e_c$ is an
  expression that should evaluate to a possibly incomplete event (i.e.~a
  channel name with zero or more fields supplied), $n \ge 0$, and each~$f_i$
  is a field of one of the following forms:
  %
  \begin{itemize}
  \item $? pat$, where $pat$ is a pattern; this offers an external choice
    between all values matching $pat$ and consistent with the channel type. 

  \item $?pat : E$, where $pat$ is a pattern, and $E$ should evaluate to a
    set; this is like the previous case, but restricts values to elements
    of~$E$. 

  \item $!e$, where $e$ is an expression; this matches only the value of~$e$. 

  \item $\$ pat$; this performs an internal choice between all values matching
    $pat$ and consistent with the channel type.
 
  \item $\$ pat : E$; this is like the previous case, but restricts values to
    elements of~$E$.
  \end{itemize}
  %
  The semantics of pattern matching by fields depends upon the field's
  location: a variable pattern (e.g.~$?x$) matches a \emph{single} complete
  value, \emph{except} in the final field where it matches the whole of the
  rest of the event.  For example, the prefix construct $c?x?y$ matches the
  event $c.1.2.3$, binding $x$ to~$1$, and $y$ to~$2.3$.

  If there are one or more \$-fields, then the process has initial
  $\tau$-transitions to resolve the internal choices; each such field is
  replaced by a field $!x$, where $x$ is a fresh variable bound in the
  environment to the value chosen; also the environment is updated
  corresponding to any other variables bound in the field.  The definition of
  \CSPm\ requires that every \$-field precedes every !- or ?-field.

  Recall that we assume that distinct variables have distinct names.  In
  particular, this means that the initial expression~$e_c$ will use no
  variables bound by a \$-field; this is required, since we will
  evaluate~$e_c$ \emph{after} the \$-fields. 

  We perform a case analysis on whether or not the prefixing construct
  contains any \$-fields.

  %%%%%%%%%%

\paragraph{Case of no \$-fields.} 

Consider first a prefixing construct of the form ${e_c~{\it fields} \then P}$
that contains no $\$$-fields.  We define the semantics of prefixing using a
function
\[
  \evalField :: 
    \begin{align}
    Env \fun Bool \fun Value \fun Field \fun  \power (Value \cross Env).
    \end{align}
\]
If $c.v$ is an incomplete event on channel~$c$, and $field$ is a field, then
%%, for a correct usage, 
$\evalField \rho~last~(c.v)~field$ gives a set of $(w,\rho')$ pairs; for each
such pair, $c.v.w$ is an extension of~$c.v$
%% compatible with~$c$,
corresponding to adding this field, and $\rho'$ is the updated environment
caused by binding any variables in patterns in~$field$.  
%% Compatibility will mean that if $\rho(c) = \channel S$ then $v.w$ is a
%% prefix of some element of~$S$; we denote this $v.w \le \rho(c)$.  However,
%% an error will occur if a $!$~field gives a value not compatible with the
%% channel.
The argument~$last$ of $\evalField$ indicates whether this is the last field
in the prefixing construct, which affects the semantics of pattern matching,
as explained above.

%% Recall that we assumed that the script is error-free.  This implies 

We prove the following
\begin{equation}\label{eqn:evalField}
f (\evalField \rho~last~(c.v)~field)  = 
    \evalField (f\after\rho)~last~(c.f(v))~field .
\end{equation}
%
We perform a case analysis on~$field$.
%
\begin{itemize}
\item Case $!e$. 
  \begin{calc}
  &  f (\evalField \rho~last~(c.v)~(!e)) \\
  = & f(\set{(\eval \rho~ e, \rho)})  \\
  = & \set{(f(\eval \rho~ e), f \after \rho)})  \\
  = & \com{inductive hypothesis applied to~$e$} \\
    & \set{(\eval (f\after\rho)~ e, f \after \rho)})  \\
  = & \evalField (f\after\rho)~last~(c.f(v))~(!e).
  \end{calc}

\item Case $?pat$.  We write $arity(pat)$ for the number of fields matched by
  $pat$ in the case that this is not the final field (so each variable matches
  a single value).  Similarly, we write $arity(w)$ for the number of complete
  values within~$w$.  Below, $W$ is the set of candidate values that $pat$
  could be matched against: it contains all values $w$, with the appropriate
  arity, that can be appended to~$v$ to give a prefix of an element
  of~$\rho(c)$.
%
  \begin{calc}
  & f (\evalField \rho~last~(c.v)~(?pat)) \\
  = & f(
    \begin{align}
    \Let W = 
      \begin{align}
      \If last \Then \set{w \mid v.w \in \rho(c)} \\
      \Else \set{w \mid v.w.u \in \rho(c), arity(pat) = arity(w)} 
      \end{align} \\
    \In 
    \set{(w, \bind \rho~pat~w) \mid w \in W, \matches \rho~pat~w})
    \end{align} \\
  = & 
    \begin{align}
    \Let W = 
      \begin{align}
      \If last \Then \set{w \mid v.w \in \rho(c)} \\
      \Else \set{w \mid v.w.u \in \rho(c), arity(pat) = arity(w)} 
      \end{align} \\
    \In 
    \set{(f(w), f \after \bind \rho~pat~w) \mid
       w \in W, \matches \rho~pat~w}
    \end{align} \\
  = & \com{parts \ref{item:matches} and \ref{item:bind};
        letting $w' = f(w)$,\, $W' = f(W)$} \\
  %% & \begin{align}
  %%   \Let W = 
  %%     \begin{align}
  %%     \If last \Then \set{w \mid v.w \in \rho(c)} \\
  %%     \Else \set{w \mid v.w.u \in \rho(c), arity(pat) = arity(w)} 
  %%     \end{align} \\
  %%   \In 
  %%   \set{(c.f(v).f(w), \bind (f\after\rho)~pat~(f(w))) \mid \\
  %%   \quad\qquad   w \in W, \matches (f\after\rho)~pat~(f(w))}
  %%   \end{align} 
  %% \\
  %% = & \com{letting $w' = f(w)$,\, $W' = f(W)$} \\
  & \begin{align}
    \Let W' = 
      \begin{align}
      \If last \Then \set{f(w) \mid v.w \in \rho(c)} \\
      \Else \set{f(w) \mid 
         \begin{align}
         v.w.u \in \rho(c), 
         arity(pat) = arity(w)} 
         \end{align}
      \end{align} \\
    \In 
    \set{(w', \bind (f\after\rho)~pat~w') \mid 
       w' \in W', \matches (f\after\rho)~pat~w'}
    \end{align} 
  \\
  = & \com{$\rho(c)$ respects $f$; Lemma \ref{lem:respects}} \\
  & \begin{align}
    \Let W' = 
      \begin{align}
      \If last \Then \set{f(w) \mid f(v).f(w) \in (f\after\rho)(c)} \\
      \Else \set{f(w) \mid 
         \begin{align}
         f(v).f(w).f(u) \in (f\after\rho)(c), \\
         arity(pat) = arity(w)} 
         \end{align}
      \end{align} \\
    \In 
    \set{(w', \bind (f\after\rho)~pat~w') \mid 
      w' \in W', \matches (f\after\rho)~pat~w'}
    \end{align} 
  \\
  = & \com{letting $w' = f(w)$,\, $u' = f(u)$; % \\
          $arity(w) = arity(f(w))$} \\
  & \begin{align}
    \Let W' = 
      \begin{align}
      \If last \Then \set{w' \mid f(v).w' \in (f\after\rho)(c)} \\
      \Else \set{w' \mid 
         \begin{align}
         f(v).w'.u' \in (f\after\rho)(c), \\
         arity(pat) = arity(w')} 
         \end{align}
      \end{align} \\
    \In 
    \set{(w', \bind (f\after\rho)~pat~w') \mid 
       w' \in W', \matches (f\after\rho)~pat~w'}
    \end{align} 
  \\
  = & \evalField (f\after\rho)~last~(c.f(v))~(?pat) .
  \end{calc}

%% *** Need that $\rho(c)$ is symmetric: if $v \in \rho(c)$ and $f(v) = f(v')$
%% then $v' \in \rho(c)$.  


\end{itemize} %% End of case analysis on field

\end{itemize}
