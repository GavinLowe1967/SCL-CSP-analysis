\section{Evaluation}

We assume a well-typed error-free script.  \framebox{**} Error-free for~$T_1$? 


We begin by defining the set of values associated with expressions in a
script.  The set $Value$ contains the union of the following. 
%
\begin{itemize}
\item Basic values: integers, booleans, and characters.

\item Datatype constructors and channel names.

\item Dotted tuples $v_1.\ldots.v_n$: in such values, we assume each
  component~$v_i$ is not a dotted term; i.e.~we treat the dot operator as
  associative, and ``flatten'' nested dots.  We sometimes write $\varepsilon$
  for the empty dotted tuple, i.e.~the unit of dot.

\item Sequences $\seq{v_1,\ldots,v_n}$, sets
  $\set{v_1,\ldots,v_n}$, tuples $(v_1,\ldots,v_n)$ and mappings
  $\set{v_1 \mapsto v_1', \ldots, v_n \mapsto v_n'}$, where each $v_i, v_i'$
  is a value.

\item Functions, considered as sets of maplets ($v \mapsto v'$); we sometimes
  represent functions using lambda abstractions.

\item Augmented LTSs (defined below), representing processes.

\item For each channel declaration $\CSPMM{channel}~c : e_1.\ldots.e_n$, a
  channel value $\channel S$, where $S$ is the set of values that can be
  passed on~$c$, i.e.~all values of the form $v_1.\ldots.v_n$ associated with
  $e_1.\ldots.e_n$.  In the case $n=0$, we use the value
  $\channel \set\varepsilon$.  We will sometimes write $v \in \rho(c)$ to mean
  $v \in S$ where $\rho(c) = \channel S$.  

\item For each datatype declaration
\[
\CSPMM{datatype}~D = 
  A_1.e_{1,1}.\ldots.e_{1,m_1} \mid \ldots \mid A_n.e_{n,1}.\ldots.e_{n,m_n}
\]
datatype constructor values $\dtcons S_i$ corresponding to~$A_i$, for
$i = 1,\ldots,n$, where $S_i$ is the set of values of the form
$v_1.\ldots.v_{m_i}$ associated with $e_{i,1}.\ldots.e_{i,m_i}$.  In the case
$m_i=0$, we use the value $\dtcons\set\varepsilon$.

\item Distinguished values $\error$ representing an error, and $\bottom$
  representing a non-terminating computation.
\end{itemize}

We use an \emph{environment} mapping identifiers (variables) to values:
\[
Env = Var \pfun Value.
\]
We write $\rho$, $\rho'$, etc., for environments. 
The type $Expr$ represents expressions.  The semantics of expressions is
defined using a function $\eval : Env \fun Expr \pfun Value$ such that
$\eval \rho~e$ gives the value of expression~$e$ in environment~$\rho$.

For later convenience, we define the semantics of processes in terms of
\emph{augmented LTSs}, where, each state is an element of $(Proc, Env)$,
i.e.~a syntactic expression (maybe with free variables) and an environment
giving values to free variables.  For example, a state might be
\[
(\If x = y \Then a \then STOP \Else b \then STOP,
   \set{x \mapsto v_1, x \mapsto v_2}).
\]
For a process expression~$P$, the value $\eval \rho~P$ is an
LTS with initial state $(P,\rho)$.
For simplicity, we assume that different identifiers (e.g.~in different
parallel components) have distinct names: this can be achieved via an
alpha-renaming.  


We define a standard partial order~$\sqsubseteq$ over $EValue$, with bottom
element~$\bottom$, and such that all the datatype constructors are continuous.

Let $f : T_1 \fun T_2$.  We extend $f$ to other
values in the obvious way.
\begin{itemize}
\item For values~$x$ not depending on~$\T$ we have $f(x) = x$: this includes
  basic values (e.g.integers and booleans), names of channels and datatype
  constructors, $\varepsilon$, $\bottom$ and $\error$.

\item We lift $f$ to dotted tuples ---including events--- by
  $f(v_1.\ldots.v_n) = f(v_1).\ldots.f(v_n)$.  This is well defined provided
  \framebox{???} (see below).

\item We lift $f$ to tuples, sets, sequences and maps by point-wise
  application.

\item We lift $f$ to functions, considered as sets of maplets, by
  \framebox{???} 
  %% $f (g) = \set{ f(x) \mapsto f(y) \mid x \mapsto y \in g }$;
  %% equivalently, in terms of a lambda-abstraction,
  %% $f(g) = \lambda z \cdot f(g(f\inverse(z)))$.

\item For channel and datatype constructor values we define
  $f(\channel S) = \channel (f(S))$, and
  $(\dtcons S) = \dtcons (f(S))$.

\item For convenience, we lift $f$ to environments by functional
  composition, i.e.~$f(\rho) = f\after\rho$.

\item We lift $f$ to LTS states by point-wise application, so $f(Q,\rho) =
  (Q, f\after\rho)$. 

\item We lift $f$ to augmented LTSs by application of~$f$ to the states
  and to the events of the transitions.  Note that, as $f$ is not necessarily
  injective, this might merge some states. 
\end{itemize}


The following definition captures our main assumption about the CSP script.
%
\begin{definition}
\label{defn:data-independent}
A CSP script is \emph{data-independent} for~$t$ if
\begin{enumerate}
\item The only constants from~$t$ that appear are within the definition
  of the instantiation of~$t$.

\item There are no equality or inequality tests over values built from~$t$.

\item When two processes synchronise on a channel built from~$t$, for each
  value from~$t$ in the corresponding events, at least one of the processes is
  willing to accept an arbitrary value.

\item The script does not apply any of the built-in functions \CSPM{member},
  \CSPM{card}, \CSPM{inter}, \CSPM{diff}, \CSPM{seq}, \CSPM{mapToList},
  \CSPM{mtransclose} or \CSPM{show} to a value built from~$t$.
  \framebox{\ldots}. 

\item The script makes no use of the compression functions \CSPM{deter},
  \CSPM{chase} or \CSPM{chase_nocache}.
\end{enumerate}
\end{definition}

Result about channel types and datatypes.  Informally, we want to say that,
for each instantiation~$T$ of~$t$, if a value $v \in T$ can appear in a
particular place in a channel of datatype value, then replacing that instance
of~$v$ by a different value~$v'$ also gives a valid channel or datatype
value.  For example, for the definitions in Figure~\ref{fig:t-allowed}, if $v
\in T$, then $c2.v.Some.v$ is a valid value; and so is $c2.v.Some.v'$ for each
$v' \in T$. 

\begin{definition}
Let $T$ be an instantiation of~$t$, let $\unit$ be a fresh value, and let
$\unitf : T \fun \set{\unit}$ be the function that maps each element of~$T$
to~$\unit$. Extend~$\unitf$ to other values in the normal way.  Then a set $S$
is \emph{$T$-invariant} if
\[
\forall w, w' \spot
  \unitf(w) = \unitf(w') \land w \in S  \implies w' \in S.
\]
\end{definition}

\begin{lemma}
\label{lem:T-invariant}
Consider a script instantiating~$t$ with~$T$.
%
\begin{itemize}
\item For every channel~$c$ declared in the script, $\eset{c}$ is $T$-invariant;

\item For every datatype~$d$ declared in the script, $d$ is
  $T$-invariant;

\item For every constructor $C$ of a datatype declared in the script,
  $\eset{C}$  is $T$-invariant.
\end{itemize}
\end{lemma}

%%%%%

\begin{proof}
We prove the result by induction over the declarations in the script.  We
prove the case for datatypes; the cases for channels and constructors are
similar but more straightforward.

Suppose $w \in d$ and $\unitf(w) = \unitf(w')$.  Suppose $w$ comes from
a branch $C.S_1.\ldots.S_k$ of the definition of~$d$, so $w$ is of the form
$C.w_1.\ldots.w_k$ where $w_i \in S_i$ for each~$i$.  Since $\unitf(w) =
\unitf(w')$,\, $w'$ must use the same constructor, and be of the form
$C.w_1'.\ldots.w_k'$, where $\unitf(w_i) = \unitf(w_i')$ for each~$i$.
We show $w_i' \in S_i$, for each~$i$, via a case analysis.
%
\begin{itemize}
\item If $S_i$ is a set that is independent of~$t$, when $w_i = \unitf(w_i) =
  \unitf(w_i') = w_i'$, so $w_i' \in S_i$.

\item If $S_i$ is a datatype, then, by induction, $S_i$ is
  $T$-invariant; hence  $w_i' \in S_i$. 

\item If $S_i$ is of the form $\eset{C_1, \ldots, C_j}$, where $C_1, \ldots,
  C_j$ are constructors of some datatype, then by induction, each of
  $\eset{C_1}, \ldots, \eset{C_j}$ is $T$-invariant; hence again $w_i' \in
  S_i$.  
\end{itemize}
%
Hence $w' = C.w_1'.\ldots.w_k' \in d$, as required.
\end{proof}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The following is the main result of this section.
%
\begin{prop}
\label{prop:expressions}
Suppose a script is data-independent for~$t$, let $T_1$ and~$T_2$ be two
instantiations of~$t$, and let $f : T_1 \fun T_2$ be surjective.  Then for
every expression~$e$ in the script, and every environment~$\rho$,
\begin{eqnarray*}
f(\eval \rho ~ e) & = \eval (f \after \rho) e .
\end{eqnarray*}
\end{prop}
%
The proof is in Appendix~\ref{sec:proof}.
