
datatype ThreadID = AltThread | T1 | T2 -- | T3 -- | T4
-- Thread AltThread will run the Alt; other threads will act on channels
datatype AltID = Alt1 -- | Alt2
datatype ChanID = c1 | c2

include "Types.csp"
include "Alt.csp"
include "Macros.csp"

-- The list of branches
branches =  <c1,c2>

instance A1 = Alt(Alt1, branches, ThreadID, ChanID)

-- Indices of branches
Index = {0 .. length(branches)-1}

-- Index of channel c in branches
index(c) = 
  let index1(c,cs) = if c == head(cs) then 0 else 1 + index1(c, tail(cs))
  within index1(c, branches)

----- The thread that runs the Alt repeatedly. 

channel beginAlt : ThreadID
channel endAlt : ThreadID . {0,1} . Data

Thread0(me) = 
  beginAlt.me -> A1::Run(me, \ i,x @ endAlt.me.i.x -> A1::Reset(me))

Thread(me) = Thread0(me); Thread(me)

----- Process modelling the contract of a channel the Alt tries to receive on.

ChanThreads =  diff(ThreadID,{AltThread})
-- sendX.t.c.x represents thread t registering its interest to send x on c.
channel beginSend, sendX : ChanThreads . ChanID . Data
channel endSend, endSendX : ChanThreads . ChanID
channel registerIn : ThreadID . AltID . ChanID . Index . RegisterInResult
channel deregisterIn : ThreadID . AltID . ChanID . Index

-- IMPROVE names and commends above, esp sendX, endSendX

isEmptyMap(senderMap) = null(mapToList(senderMap))

-- Model of the contract of channel c.  
Channel(c) = Channel0(c, emptyMap)

-- IMPROVE: at most one thread can have registered its interest to send, so we
-- don't need a map.

-- Channel with no registered alt. The parameter senderMap: (| ThreadID =>
-- Data |) records values that threads are attempting to send.
Channel0(c, senderMap) = 
  isEmptyMap(senderMap) & ([] t : ChanThreads @ not(mapMember(senderMap, t)) & 
     sendX.t.c?x -> Channel0(c, mapUpdate(senderMap, t, x)))
  []
  RegisterIn(c, senderMap)

-- Allow alt to register with this channel, depending appropriately depending
-- on whether a thread has registered its interest to send.  
RegisterIn(c, senderMap) = 
  if isEmptyMap(senderMap) then 
    registerIn?_?alt!c?index!RegisterInWaiting ->
    Channel'(c, alt, index)
  else 
    |~| (t,x) : set(mapToList(senderMap)) @ 
      registerIn?_?alt!c?index!RegisterInSuccess.x -> endSendX.t.c ->
      Channel0(c, mapDelete(senderMap, t))

-- Channel that has alt registered with index. 
Channel'(c,alt,index) = 
  DeregisterIn(c,alt,index); Channel0(c, emptyMap)
  []
  sendX?t!c?x -> Channel''(c,alt,index,t,x) 

-- Be deregistered by alt with index, then terminate.
DeregisterIn(c,alt,index) = 
  deregisterIn?_?alt'!c?index' -> Assert1(alt' == alt and index' == index)

-- Channel has alt registered, and thread t is trying to send x
Channel''(c,alt,index,t,x) = 
  DeregisterIn(c,alt,index); Channel0(c, mapFromList(<(t,x)>)) 
  []
  A1::MaybeReceive(t, x, index, PostMaybeReceive(c,alt,t,index,x))

-- The channel has performed maybeReceive(x,index).  The final parameter
-- represents the result.
PostMaybeReceive(c,alt,t,index,x)(true) = endSendX.t.c -> Channel0(c, emptyMap) 
PostMaybeReceive(c,alt,t,index,x)(false) = 
  PostMaybeReceive'(c, mapFromList(<(t,x)>), alt, index)

PostMaybeReceive'(c, senderMap, alt, index) =
  -- More channels may try to send
  isEmptyMap(senderMap) & ([] t : ChanThreads @ not(mapMember(senderMap, t)) & 
     sendX.t.c?x -> PostMaybeReceive'(c, mapUpdate(senderMap, t, x), alt, index) 
  )
  [] 
  -- The attempt to send failed; the alt may still deregister with this.
  DeregisterIn(c,alt,index); Channel0(c, senderMap) 
  []
  -- If a registerIn happens, then the deregisterIn isn't going to happen
  RegisterIn(c, senderMap)


ChannelInterface(c) =
  A1::beginRegisterIn?t1?alt!c?index -> registerIn.t1.alt.c.index?result ->
    A1::endRegisterIn.t1.alt.c.result -> ChannelInterface(c)
  []
  A1::beginDeregisterIn?t1?alt!c?index -> deregisterIn.t1.alt.c.index ->
    A1::endDeregisterIn.t1.alt.c -> ChannelInterface(c)

WrappedChannel(c) = 
  let syncSet = 
    {| registerIn.t1.alt.c, deregisterIn.t1.alt.c | 
         t1 <- ThreadID, alt <- AltID |} 
  within
  (Channel(c) [| syncSet |] ChannelInterface(c)) \ syncSet


-- Interface between sending thread t and the channel.
ChannelThreadInterface(t) = 
  beginSend.t?c?x -> sendX.t.c.x -> endSendX.t.c -> endSend.t.c -> 
    ChannelThreadInterface(t)
  |~| STOP

Channels =
  (||| c <- ChanID @ WrappedChannel(c)) 
  [| {| sendX,endSendX |} |] 
  (||| t <- ChanThreads @ ChannelThreadInterface(t))

alphaChannels = 
  {| A1::beginRegisterIn, A1::endRegisterIn, 
     A1::beginDeregisterIn, A1::endDeregisterIn |}

--------- Construct system

System0 = Thread(AltThread) [| alphaChannels |] (Channels \ {|sendX,endSendX|})

-- System1 = A1::runWith(System0)

System2 = A1::runWithAndHide(System0)

System = System2 \ union(alphaChannels, {|A1::spuriousWakeUp|}) 

assert System2 :[divergence free] -- succeeds.

assert not System :[divergence free] -- diverges because of spurious wake ups

assert not System2 :[deadlock free]
-- Can deadlock if both channels could refuse to communicate.

------ Specification for synchronisation linearisation.

-- Synchronisation between thread in Alt and channel, passing data value.
channel sync : ThreadID . ChanID . Data

-- Lineariser of thread in Alt.
AltLin(me) = beginAlt.me -> sync.me?c?x -> endAlt.me.index(c).x -> AltLin(me)

-- Lineariser of thread sending on channel c.
ChanLin(c,t) = 
  beginSend.t!c?x -> sync.AltThread!c!x -> endSend.t.c -> ChanLin(c,t) 
  |~| STOP

ChanLins = ||| c <- ChanID, t <- ChanThreads @ ChanLin(c,t)

Spec = (AltLin(AltThread) [| {| sync.AltThread |} |] ChanLins) \ {| sync |}

assert Spec [T= System

assert Spec [F= System