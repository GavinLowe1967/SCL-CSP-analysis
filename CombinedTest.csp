-- A test on the combination of an alt and two channels.
-- This file needs to be included in a file that defines the list of branches.

-- Thread identities.  Thread AltThread will run the Alt; other threads will
-- act on channels.
datatype ThreadID = AltThread | T1 | T2 -- | T3 -- | T4

others(t) = diff(ChanThreads, {t})

ChanThreads =  diff(ThreadID, {AltThread})

-- Identities of channels
datatype ChanID = Chan1 | Chan2 -- c1 | c2

include "Types.csp"

-- Identities of Alts
datatype AltID = Alt1 -- | Alt2

-- The list of branches in the alt.  The main file needs to include a
-- definition like one of the following.
-- branches =  <InPortBranch.c1, InPortBranch.c2>
-- branches =  <InPortBranch.c1, OutPortBranch.c2>

size = length(branches)

Index = {0..size-1}

-- Index of channel c in branches
index(c) = 
  let index1(c,cs) = if c == head(cs) then 0 else 1 + index1(c, tail(cs))
  within index1(c, branches)

Strict = false

-- Execute P if Strict is set.  Used for optional assertions. 
IfStrict(P) = if Strict then P else SKIP

-- include "SyncChanAlt.csp"
include "NewSyncChan.csp" 

-- Create two channels
instance C1 = SyncChan(ThreadID, AltID, Data, size)
instance C2 = SyncChan(ThreadID, AltID, Data, size)

include "Alt.csp"

-- Create the alt.
instance A1 = Alt(Alt1, branches, ThreadID, ChanID)

------ Threads

-- The thread that runs the Alt repeatedly. 


CLOSEFLAG = true --  not FLAG

TheAltThread(me) = RUN(A1::altInterface(AltThread))
--   A1::beginAlt.me -> (
--     A1::endAlt.me.AltReceive?i.x -> TheAltThread(me) 
--     [] 
--     A1::endAlt.me.AltSend?i.x -> TheAltThread(me)
-- -- FIXME: or AltAbort
--   )

-- Thread with identity me, which repeatedly calls operations.  In particular,
-- this prevents the thread from apparently having concurrent invocations on
-- both channels.
Thread(me) = 
  C1::beginSend.me?x -> C1::endSend.me?res -> Thread(me) 
  []
  C2::beginSend.me?x -> C2::endSend.me?res -> Thread(me)
  []
  C1::beginReceive.me -> C1::endReceive.me?res -> Thread(me)
  []
  C2::beginReceive.me -> C2::endReceive.me?res -> Thread(me)
  []
  C1::beginSendWithin.me?x -> C1::endSendWithin.me?b -> Thread(me)
  []
  C2::beginSendWithin.me?x -> C2::endSendWithin.me?b -> Thread(me)
  []
  C1::beginReceiveWithin.me -> C1::endReceiveWithin.me?ox -> Thread(me)
  []
  C2::beginReceiveWithin.me -> C2::endReceiveWithin.me?ox -> Thread(me)
  []
CLOSEFLAG & (
  C1::beginClose.me -> C1::endClose.me -> Thread(me)
  []
  C2::beginClose.me -> C2::endClose.me -> Thread(me)
)

Threads = (||| t <- ChanThreads @ Thread(t)) ||| TheAltThread(AltThread)

-- Put the system together

-- Run Threads with C1 and C2, and rename events to be consistent with the
-- alt.
System00 = C1::runWithClientsAndHide(C2::runWithClientsAndHide(Threads))

System01 = 
  System00 [[
    C1::beginRegisterIn.t.Alt1 <- A1::beginRegisterIn.t.Chan1,
    C1::endRegisterIn.t.Alt1 <- A1::endRegisterIn.t.Chan1,
    C1::beginDeregisterIn.t.Alt1 <- A1::beginDeregisterIn.t.Chan1,
    C1::endDeregisterIn.t.Alt1 <- A1::endDeregisterIn.t.Chan1,
    C1::beginRegisterOut.t.Alt1 <- A1::beginRegisterOut.t.Chan1,
    C1::endRegisterOut.t.Alt1 <- A1::endRegisterOut.t.Chan1,
    C1::beginDeregisterOut.t.Alt1 <- A1::beginDeregisterOut.t.Chan1,
    C1::endDeregisterOut.t.Alt1 <- A1::endDeregisterOut.t.Chan1,

    C1::beginMaybeReceive.t.Alt1 <- A1::beginMaybeReceive.t,
    C1::endMaybeReceive.t.Alt1 <- A1::endMaybeReceive.t,
    C1::beginMaybeSend.t.Alt1 <- A1::beginMaybeSend.t,
    C1::endMaybeSend.t.Alt1 <- A1::endMaybeSend.t,
    C1::beginPortClosed.t.Alt1 <- A1::beginPortClosed.t,
    C1::endPortClosed.t.Alt1 <- A1::endPortClosed.t,

    C2::beginRegisterIn.t.Alt1 <- A1::beginRegisterIn.t.Chan2,
    C2::endRegisterIn.t.Alt1 <- A1::endRegisterIn.t.Chan2,
    C2::beginDeregisterIn.t.Alt1 <- A1::beginDeregisterIn.t.Chan2,
    C2::endDeregisterIn.t.Alt1 <- A1::endDeregisterIn.t.Chan2,
    C2::beginRegisterOut.t.Alt1 <- A1::beginRegisterOut.t.Chan2,
    C2::endRegisterOut.t.Alt1 <- A1::endRegisterOut.t.Chan2,
    C2::beginDeregisterOut.t.Alt1 <- A1::beginDeregisterOut.t.Chan2,
    C2::endDeregisterOut.t.Alt1 <- A1::endDeregisterOut.t.Chan2,

    C2::beginMaybeReceive.t.Alt1 <- A1::beginMaybeReceive.t,
    C2::endMaybeReceive.t.Alt1 <- A1::endMaybeReceive.t,
    C2::beginMaybeSend.t.Alt1 <- A1::beginMaybeSend.t,
    C2::endMaybeSend.t.Alt1 <- A1::endMaybeSend.t,
    C2::beginPortClosed.t.Alt1 <- A1::beginPortClosed.t,
    C2::endPortClosed.t.Alt1 <- A1::endPortClosed.t
      | t <- ThreadID 
  ]]

System0 = A1::runWithAndHide(System01) \ A1::ChannelInterface

assert System0 :[divergence free]
-- Check requires ~250GB. 

assert not System0 :[deadlock free] 
-- deadlocks because all ChanThreads could choose to use the same port as the
-- alt.

System = System0 \ {|A1::spuriousWakeup|} 

assert not System :[divergence free] 
-- diverges because of spurious wake ups

------ Specification for synchronisation linearisation.

include "CombinedSpec.csp"

-- -- In sync and altSync events, the sender comes first

-- -- Synchronisation between threads in Alt and channel, passing data value.
-- channel altSync : ThreadID . ThreadID . ChanID . Data

-- -- synchronsation between a sender and receiver
-- channel sync : ThreadID . ThreadID . ChanID . Data

-- -- channel closing linearization point
-- channel close: ThreadID . ChanID

-- -- Test of whether the channel is closed. 
-- channel isClosed: ThreadID . ChanID

-- channel allClosed

-- -- A thread timing out in a sendWithin or receiveWithin.
-- channel timeout: ThreadID . ChanID

-- Specification object for a channel: keeps track of whether the channel is
-- closed, allowing appropriate events before and after.
-- ChanSpec(c) = 
--   sync?_?_!c?_ -> ChanSpec(c) 
--   [] altSync?_?_!c?_ -> ChanSpec(c) 
--   [] timeout?_!c -> ChanSpec(c)
--   [] close?_!c -> ChanSpecClosed(c)
-- ChanSpecClosed(c) =
--   isClosed?_!c -> ChanSpecClosed(c) 
--   [] allClosed -> ChanSpecClosed(c)
--   [] close?_!c -> ChanSpecClosed(c)

-- ChanSpecs = [| {allClosed} |] c <- ChanID @ ChanSpec(c)
-- alphaChanSpecs = {| sync, altSync, timeout, close, isClosed, allClosed |} 

-- -- Lineariser for the Alt thread.
-- AltLin(me) = 
--   let inPorts = { c | InPortBranch.c <- set(branches) }
--       outPorts = { c | OutPortBranch.c <- set(branches) } 
--   within
--   A1::beginAlt.me -> (
--     altSync.me?other:ChanThreads?c:inPorts?x -> 
--       A1::endAlt.me.AltReceive.index(InPortBranch.c).x -> AltLin(me)
--     []
--     altSync?other:ChanThreads!me?c:outPorts?x ->
--       A1::endAlt.me.AltSend.index(OutPortBranch.c).x -> AltLin(me)
--     []
--     allClosed -> A1::endAlt.me.AltAbort -> AltLin(me)
--   )

-- alphaAltLin(me) = union(
--   {| A1::beginAlt.me, A1::endAlt.me, altSync.me, allClosed |},
--   {| altSync.t.me | t <- ChanThreads |}
-- )

-- Lineariser for a channel thread.
-- ChanThreadLin(me) = 
--   C1::beginSend.me?x -> LinSending(me, x, c1, C1::endSend.me)
--   []
--   C2::beginSend.me?x -> LinSending(me, x, c2, C2::endSend.me)
--   []
--   C1::beginReceive.me -> LinReceiving(me, c1, C1::endReceive.me) 
--   []
--   C2::beginReceive.me -> LinReceiving(me, c2, C2::endReceive.me)
--   [] 
--   C1::beginSendWithin.me?x -> LinSendingWithin(me, x, c1, C1::endSendWithin.me)
--   []
--   C2::beginSendWithin.me?x -> LinSendingWithin(me, x, c2, C2::endSendWithin.me)
--   []
--   C1::beginReceiveWithin.me -> 
--     LinReceivingWithin(me, c1, C1::endReceiveWithin.me)
--   []
--   C2::beginReceiveWithin.me -> 
--     LinReceivingWithin(me, c2, C2::endReceiveWithin.me)
--   []
--   C1::beginClose.me -> close.me.c1 -> C1::endClose.me -> ChanThreadLin(me)
--   []
--   C2::beginClose.me -> close.me.c2 -> C2::endClose.me -> ChanThreadLin(me)

-- -- Thread me sending x on c; endChan will signal the end of the sending. 
-- LinSending(me, x, c, endChan) = 
--   sync.me?other:others(me)!c!x -> endChan.SendSuccess -> ChanThreadLin(me)
--   [] 
--   altSync?altThread!me!c!x -> endChan.SendSuccess -> ChanThreadLin(me)
--   [] 
--   isClosed.me.c -> endChan.Closed -> ChanThreadLin(me)

-- -- Thread me receiving on c; endChan will signal the end of the receive. 
-- LinReceiving(me, c, endChan) = 
--   sync?other:others(me)!me!c?x -> endChan.ReceiveSuccess.x -> ChanThreadLin(me)
--   [] 
--   altSync.me?altThread!c?x -> endChan.ReceiveSuccess.x -> ChanThreadLin(me)
--   [] 
--   isClosed.me.c -> endChan.Closed -> ChanThreadLin(me)

-- -- Thread me within sendWithin(x) on c; endChan will signal the end of the
-- -- sending.
-- LinSendingWithin(me, x, c, endChan) = 
--   LinSending(me, x, c, endChan)
--   -- [> endChan.me.Timeout -> ChanThreadLin(me)
--   [] timeout.me.c -> endChan.Timeout -> ChanThreadLin(me)

-- -- Thread me within receiveWithin(x) on c; endChan will signal the end of the
-- -- receiving.
-- LinReceivingWithin(me, c, endChan) = 
--   LinReceiving(me, c, endChan)
--   --  [> endChan.me.Timeout -> ChanThreadLin(me) 
--   [] timeout.me.c -> endChan.Timeout -> ChanThreadLin(me) 


beginAlt = A1::beginAlt
endAlt = A1::endAlt

-- Definitions of the ChanIDs and (CSP) channels used for beginning and ending
-- operations.
sendChans = {
  (Chan1, C1::beginSend, C1::endSend), (Chan2, C2::beginSend, C2::endSend)
}
receiveChans = {
  (Chan1, C1::beginReceive, C1::endReceive), 
  (Chan2, C2::beginReceive, C2::endReceive)
}
sendWithinChans =  {
  (Chan1, C1::beginSendWithin, C1::endSendWithin), 
  (Chan2, C2::beginSendWithin, C2::endSendWithin)
} 
receiveWithinChans = {
  (Chan1, C1::beginReceiveWithin, C1::endReceiveWithin), 
  (Chan2, C2::beginReceiveWithin, C2::endReceiveWithin)
}
closeChans = {
  (Chan1, C1::beginClose, C1::endClose), (Chan2, C2::beginClose, C2::endClose)
}
clientInterface(me) = union(C1::clientInterface(me), C2::clientInterface(me))

-- -- Alphabet of ChanThreadLin(me)
-- alphaChanThreadLin(me) = Union({
--   C1::clientInterface(me),
--   C2::clientInterface(me),
--   {| sync.me.t, sync.t.me | t <- diff(ThreadID,{me}) |},
--   {| altSync.AltThread.me, altSync.me.AltThread, 
--      timeout.me, close.me, isClosed.me |}
-- })

-- Lin(me) = if me == AltThread then AltLin(me) else ChanThreadLin(me)

-- alphaLin(me) = 
--   if me == AltThread then alphaAltLin(me) else alphaChanThreadLin(me)
  
-- -- Combine the linearisers to create the specification
-- Spec = (
--   (|| t <- ThreadID @ [alphaLin(t)] Lin(t)) 
--   [| alphaChanSpecs |]
--   ChanSpecs
-- ) \ alphaChanSpecs 

assert Spec [T= System

assert Spec [F= System 

-- The following test keeps the spurious wakeups visible.

Spec1 = Spec ||| CHAOS({|A1::spuriousWakeup|})

assert Spec1 [F= System0 

assert Spec1 [FD= System0 
-- Warning: above requires ~500GB of memory! 