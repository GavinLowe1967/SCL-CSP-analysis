-- A model of an Alt with identity this, and branches given by branches.  
module Alt(this, branches, ThreadID, ChanID)
  include "Variable.csp"
  include "Macros.csp"

  include "JVMMonitor.csp"

  -- The registering variable
  channel getRegistering, setRegistering : ThreadID . Bool
  Registering = Var(true, getRegistering, setRegistering)

  -- The done variable
  channel getDone, setDone : ThreadID . Bool
  Done = Var(false, getDone, setDone)

  size = length(branches)

  -- Indices of branches
  Index = {0 .. size-1}

  -- The toRun variable.
  channel getToRun, setToRun : ThreadID . union({(-1)}, Index)
  ToRun = Var(-1, getToRun, setToRun)

  -- The value received.  
  channel getValueReceived, setValueReceived : ThreadID . Data
  ValueReceived = Var(A, getValueReceived, setValueReceived)

  -- The value sent.  This is not actually part of the implementation, but is
  -- needed to capture the specification.
  channel getValueSent, setValueSent : ThreadID . Option
  ValueSent = Var(None, getValueSent, setValueSent)

  -- The array of enabled variables
  channel getEnabled, setEnabled : ThreadID . Index . Bool
  Enabled = Array(Index, false, getEnabled, setEnabled)

  -- All variables
  Variables = 
    Registering ||| Done ||| ToRun ||| ValueReceived ||| ValueSent ||| Enabled

  varEvents = {|
    getRegistering, setRegistering, getDone, setDone, getToRun, setToRun, 
    getValueReceived, setValueReceived, getValueSent, setValueSent, 
    getEnabled, setEnabled
  |} 

  ---------- 

  -- The n'th element of a sequence
  nth(xs, 0) = head(xs)
  nth(xs, n) = nth(tail(xs), n-1)

  events = union(varEvents, JVMMonitor::events)

  ---------- Model of code

  --------- Run the Alt, and apply cont to the value received.
  Run :: (ThreadID, (AltResult) -> Proc) -> Proc
  Run(me, cont) = -- Register(me, cont)
    JVMMonitor::Synchronized(me, setRegistering.me.true -> SKIP);
    Register(me, cont, 0)

  -- Register with branches from index i.
  Register(me, cont, i) = 
    if i == size then AfterLoop(me, cont)
    else Register1(me, cont, i, nth(branches, i)) 

  Register1(me, cont, i, InPortBranch.c) = 
    beginRegisterIn.me.this.c.i -> (
      endRegisterIn.me.this.c.RegisterInSuccess?x -> 
        setValueReceived.me.x -> setToRun.me.i -> 
        setDone.me.true -> AfterLoop(me, cont)
      [] 
      endRegisterIn.me.this.c.RegisterInWaiting -> 
        setEnabled.me.i.true -> Register(me, cont, i+1)
    )

  Register1(me, cont, i, OutPortBranch.c) = 
-- IMPROVE: value shouldn't be chosen here
    beginRegisterOut.me.this.c.i$x -> (
      endRegisterOut.me.this.c.RegisterOutSuccess -> setToRun.me.i -> 
        setDone.me.true -> setValueSent.me.Some.x -> AfterLoop(me, cont)
      []
      endRegisterOut.me.this.c.RegisterOutWaiting -> 
        setEnabled.me.i.true -> Register(me, cont, i+1)
    )

  -- Code after the registration loop.  
  AfterLoop(me, cont) = 
    JVMMonitor::Synchronized(me, AfterLoop1(me, cont));
    PostWait(me, cont)

  -- The body of the synchronized block. 
  AfterLoop1(me, cont) = 
    setRegistering.me.false -> JVMMonitor::NotifyAll(me);
    getDone.me?done -> 
    if not done then
      let Test(k) = getDone.me?done -> k(not done) within
      While(Test, JVMMonitor::Wait(me))
    else SKIP

  -- Code after the (possible) wait
  PostWait(me, cont) = 
    getDone.me?done -> Assert1(done); PostWait1(me, cont, 0)

  -- Deregister branches[i..size)
  PostWait1(me, cont, i) = 
    if i == size then RunBranch(me, cont)
    else 
      getToRun.me?toRun -> getEnabled.me.i?enabled -> 
      if i != toRun and enabled then 
        Deregister(me, cont, i, nth(branches,i)); PostWait1(me, cont, i+1)
      else PostWait1(me, cont, i+1)

  -- Deregister branch at index i.
  Deregister(me, cont, i, InPortBranch.c) = 
    beginDeregisterIn.me.this.c.i -> endDeregisterIn.me.this.c -> SKIP

  Deregister(me, cont, i, OutPortBranch.c) = 
    beginDeregisterOut.me.this.c.i -> endDeregisterOut.me.this.c -> SKIP

  -- Run the branch toRun.
  RunBranch(me, cont) = 
    getToRun.me?toRun -> 
    Assert(toRun >= 0, RunBranch1(me, cont, toRun, nth(branches, toRun)))

  RunBranch1(me, cont, toRun, InPortBranch.c) = 
    getValueSent.me?oValue -> Assert1(oValue == None);
    getValueReceived.me?valueReceived -> cont(AltReceive.toRun.valueReceived)

  RunBranch1(me, cont, toRun, OutPortBranch.c) = 
    getValueSent.me?oValue -> 
    Assert(oValue != None, let Some.x = oValue within cont(AltSend.toRun.x))

  ------ Reset for next round

  Reset(me) = JVMMonitor::Synchronized(me, Reset1(me, 0))

  -- Clear enabled[i..size).
  Reset1(me,i) = 
    if i < size then setEnabled.me.i.false -> Reset1(me,i+1)
    else setToRun.me.(-1) -> setDone.me.false -> setValueSent.me.None -> SKIP

  -------- The maybeReceive function

  -- maybeReceive function; try to get Alt to receive value from the InPort of
  -- branch index.  Apply cont to Bool indicating if successful.
  MaybeReceive :: (ThreadID, Data, Int, (Bool) -> Proc) -> Proc
  MaybeReceive(me, value, index, cont) = 
    JVMMonitor::SynchronizedC(me, MaybeReceive1(me, value, index), cont)

  -- while(registering) wait() 
  WaitWhileRegistering(me) = 
    let Test(k) = getRegistering.me?registering -> k(registering) within
    While(Test, JVMMonitor::Wait(me))

  -- Body of maybeReceive
  MaybeReceive1(me, value, index)(cont) = 
    WaitWhileRegistering(me);
    -- assert(enabled(index))
    getEnabled.me.index?enab -> Assert1(enab);
    -- if(done) ...
    getDone.me?done -> 
    if done then
      -- enabled(index) = false; false
      setEnabled.me.index.false -> cont(false)
    else  
      -- assert(enabled(index)); enabled(index) = false
      getEnabled.me.index?enab -> Assert1(enab); setEnabled.me.index.false ->
      -- valueReceived = value
      setValueReceived.me.value -> 
      -- toRun = index; done = true; notify(); true
      setToRun.me.index -> setDone.me.true -> 
      JVMMonitor::Notify(me); cont(true)

  -------- The maybeSend function

  MaybeSend :: (ThreadID, Int, (Option) -> Proc) -> Proc
  MaybeSend(me, index, cont) =
    JVMMonitor::SynchronizedC(me, MaybeSend1(me, index), cont)

  MaybeSend1(me, index)(cont) =  
    WaitWhileRegistering(me);
    -- assert(numEnabled > 0 && enabled(index))
    -- getNumEnabled.me?ne -> Assert1(ne > 0); 
    getEnabled.me.index?enab -> Assert1(enab);
    -- if(done){ enabled(index) = false; None }
    getDone.me?done ->
    if done then setEnabled.me.index.false -> cont(None)
    else
      -- enabled(index) = false; toRun = index; done = true; notify();
      setEnabled.me.index.false -> setToRun.me.index -> setDone.me.true ->
      JVMMonitor::Notify(me);
      -- val result = opb.value(); Some(result)
-- IMPROVE: don't pick x here
      setValueSent.me.Some$x -> cont(Some.x)

  -------- Threads that interact with the alt

  -- Thread me interacting with the alt, corresponding to the main run function
  -- and the maybeReceive function.  
  Thread(me) = 
    beginAlt.me -> Run(me, \ res @ endAlt.me.res -> Reset(me)); Thread(me)
    []
    beginMaybeSend.me?index ->
       MaybeSend(me, index, \ res @ endMaybeSend.me.res -> Thread(me))
    []
    beginMaybeReceive.me?index.x -> 
      MaybeReceive(me, x, index, \ res @ endMaybeReceive.me.res -> Thread(me))

  Threads = ||| t <- ThreadID @ Thread(t)

  ---- The internals of the Alt: threads, variables, monitor.
  Internals = JVMMonitor::runWith(Threads [| varEvents |] Variables)

  ---- Interface with clients
  AltInterface = {| beginAlt, endAlt |}

  Interface = union( AltInterface, ChannelInterface )

exports
  
  -- The type of information about how an alt ended.
  datatype AltResult = AltReceive.Index.Data | AltSend.Index.Data

  -- Events for invocations of the main run function.
  channel beginAlt: ThreadID
  channel endAlt: ThreadID . AltResult -- Index . Data

  -- Events for invocations of maybeReceive, maybeSend.
  channel beginMaybeReceive: ThreadID . Index . Data
  channel endMaybeReceive : ThreadID . Bool

  channel beginMaybeSend : ThreadID . Index
  channel endMaybeSend : ThreadID . Option 

  -- Channels for operations the alt calls on ports.
  channel beginRegisterIn : ThreadID . {this} . ChanID . Index
  channel endRegisterIn : ThreadID . {this} . ChanID . RegisterInResult
  channel beginRegisterOut : ThreadID . {this} . ChanID . Index . Data
  channel endRegisterOut : ThreadID . {this} . ChanID . RegisterOutResult

  channel beginDeregisterIn : ThreadID . {this} . ChanID . Index
  channel endDeregisterIn : ThreadID . {this} . ChanID
  channel beginDeregisterOut : ThreadID . {this} . ChanID . Index 
  channel endDeregisterOut : ThreadID . {this} . ChanID

  spuriousWakeUp = JVMMonitor::spuriousWakeup

  -- The interface between the alt and channels (in both directions). 
  ChannelInterface = 
    {| beginRegisterIn, endRegisterIn, beginRegisterOut, endRegisterOut,
       beginDeregisterIn, endDeregisterIn, beginDeregisterOut, endDeregisterOut,
       beginMaybeSend, endMaybeSend, beginMaybeReceive, endMaybeReceive |}

  ----- Administrative functions.

  -- Run P with this Alt
  runWith(P) = P [| Interface |] Internals

  -- Run P with this Alt, and hide internals except spuriousWakeup
  runWithAndHide(P) = runWith(P) \ events

endmodule