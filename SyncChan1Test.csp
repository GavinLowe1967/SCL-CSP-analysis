-- Test upon SyncChan1

datatype ThreadID = T1 | T2 | T3 | T4
datatype Data = A | B

include "SyncChanV1.csp"

-- We'll test a single channel
instance c = SyncChan(ThreadID, Data)

-- Signals before and after invocations.
channel beginSend, endReceive : ThreadID . Data
channel beginReceive, beginReceiveWithin, endSend : ThreadID
channel endReceiveWithin : ThreadID . (c::Option)

-- Thread with identity me, which repeatedly sends or receives, or neither.
Thread(me) = 
  let handleReceive(x) = endReceive.me.x -> SKIP within
  beginSend.me?x -> c::Send(me, x); endSend.me -> Thread(me)
  |~|
  beginReceive.me -> c::Receive(me, \ x @ endReceive.me.x -> SKIP ); Thread(me)
  |~|
  beginReceiveWithin.me -> 
    c::ReceiveWithin(me, \ ox @ endReceiveWithin.me.ox -> SKIP); Thread(me)
  |~| 
  STOP

Threads = ||| t <- ThreadID @ Thread(t)

System = c::runWithAndHide(Threads)

assert System  :[divergence free]
-- assert System  :[deadlock free [F]] -- doesn't hold if thread can STOP!

-- Specification of synnchronisation linearisation.

-- sync.t1.t2.x represents sender t1 and receiver t2 synchronising on the
-- sending of x.
channel sync : ThreadID . ThreadID . Data

Linearizer(me) = 
  beginSend.me?x -> sync.me?other!x -> endSend.me -> Linearizer(me)
  |~|
  beginReceive.me -> sync?other!me?x -> endReceive.me.x -> Linearizer(me)
  |~|
  beginReceiveWithin.me ->
    (sync?other!me?x -> endReceiveWithin.me.(c::Some.x) -> Linearizer(me)
     [> endReceiveWithin.me.(c::None) -> Linearizer(me))
  |~| 
  STOP

Spec = 
  let alpha(t) = 
    {| beginSend.t, endSend.t, beginReceive.t, endReceive.t, 
       beginReceiveWithin.t, endReceiveWithin.t, sync.t.other, sync.other.t | 
         other <- diff(ThreadID,{t}) |} 
  within (|| t <- ThreadID @ [alpha(t)] Linearizer(t)) \ {| sync|}


assert Spec [T= System
assert Spec [F= System