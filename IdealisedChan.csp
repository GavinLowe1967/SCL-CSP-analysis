-- An idealised model of a SyncChan.

-- This module assumes that the following are in scope: (1) the definitions in
-- Types.csp; (2) a definition of ThreadID, including AltThread, and a
-- corresponding definition of ChanThreads; (3) a definition of AltID,
-- including Alt1.

module IdealisedChan(size)

  -- Possible indices of branches.
  Index = {0..size-1}

  -- Macros for set operations
  add(set,x) = union(set,{x})
  remove(set,x) = diff(set,{x})

  -- Channel threads other than t.
  others(t) = diff(ChanThreads, {t})
  
  --------- Lineariser for registration and deregistration
  
  -- Linearisation points of register(In|Out) corresponding to a synchronisation,
  -- waiting, or an out-of-protocol call.
  channel registerInSync, registerOutSync : ChanThreads . Data
  channel registerInWait, registerOutWait : Index 
  channel registerError 
  -- Linearisation points of deregistration, corresponding to legal or
  -- out-of-protocol cases.
  channel deregisterIn, deregisterInError, deregisterOut, deregisterOutError : 
    Index
  
  -- Thread finding the channel is closed.
  channel isClosed : ThreadID
  
  -- Lineariser for registration and deregistration events.
  RegLin = 
    beginRegisterIn.AltThread.Alt1?index -> RegLinRegIn(index)
    []
    beginDeregisterIn.AltThread.Alt1?index -> RegLinDeregIn(index)
    []
    beginRegisterOut.AltThread.Alt1?index -> RegLinRegOut(index)
    []
    beginDeregisterOut.AltThread.Alt1?index -> RegLinDeregOut(index)
  
  -- Alt registering at inport against index.
  RegLinRegIn(index) = 
    registerInSync?t?x -> endRegisterIn.AltThread.Alt1.RegisterSuccess.x ->
    RegLin
    []
    registerInWait.index -> endRegisterIn.AltThread.Alt1.RegisterWaiting ->
    RegLin
    []
    isClosed.AltThread -> endRegisterIn.AltThread.Alt1.RegisterClosed ->
    RegLin
    []
    registerError -> STOP
  
  -- Alt deregistering at inport against index.
  RegLinDeregIn(index) = 
    deregisterIn.index -> endDeregisterIn.AltThread.Alt1 -> RegLin
    [] deregisterInError.index -> STOP
  
  -- Alt deregistering at outport against index.
  RegLinRegOut(index) = 
    ( |~| x : Data @ registerOutSync?t!x -> 
       endRegisterOut.AltThread.Alt1.RegisterSuccess.x -> RegLin
    )
    []
    registerOutWait.index -> 
    endRegisterOut.AltThread.Alt1.RegisterWaiting -> RegLin
    []
    isClosed.AltThread -> endRegisterOut.AltThread.Alt1.RegisterClosed ->
    RegLin
    []
    registerError -> STOP
  
  -- Alt deregistering at outport against index.
  RegLinDeregOut(index) = 
    deregisterOut.index -> endDeregisterOut.AltThread.Alt1 -> RegLin
    [] deregisterOutError.index -> STOP

  -- Linearisation points of registration and deregistration.
  RegLPs = {| 
    registerInSync, registerInWait, registerOutSync, registerOutWait,
    registerError,
    deregisterIn, deregisterInError, deregisterOut, deregisterOutError 
  |}

  alphaRegLin = Union({
    AltRegistrationEvents, RegLPs, {| isClosed.AltThread |}
  })
  
  ------------ Linearisers for channel thread ops
  
  -- synchronsation between a sender (first field) and receiver (second field).
  channel sync : ChanThreads . ChanThreads . Data
  
  -- A thread, having synchronised with either a channel thread or the alt
  -- thread, commits to returning.  This corresponds to that thread re-acquiring
  -- the lock in the implementation.  Subsequently, the corresponding end event
  -- cannot be refused.
  channel commit : ChanThreads
  
  -- The channel chooses to call maybeReceive or maybeSend by a particular
  -- thread.
  channel callMaybeReceive : ChanThreads . Index . Data
  channel callMaybeSend : ChanThreads . Index

  -- A channel timesout within a sendWithin or receiveWithin
  channel timeout : ChanThreads
  
  -- channel closing linearization point
  channel close : ChanThreads
  
  -- A lineariser for thread me
  Lin(me) = 
    beginSend.me?x -> SendingLin(me, x)
    []
    beginReceive.me -> ReceivingLin(me)
    []
    beginSendWithin.me?x -> SendingWithinLin(me, x)
    []
    beginReceiveWithin.me -> ReceivingWithinLin(me)
    []
    beginClose.me -> close.me -> isClosed.me -> endClose.me -> Lin(me)
    -- Note: the isClosed event means the endClose happens only after the
    -- registered port (if any) has been informed.
  
  -- Lineariser for thread me inside send(x).
  SendingLin(me, x) = 
    sync.me?other:others(me)!x -> commit.me -> EndSendingLin(me)
    []
    registerInSync.me.x -> commit.me -> EndSendingLin(me)
    []
    callMaybeReceive.me?index!x -> beginMaybeReceive.me.Alt1.index.x -> 
    endMaybeReceive.me.Alt1?res -> 
    (if res then EndSendingLin(me) else SendingLin(me, x))
    []
    isClosed.me -> endSend.me.Closed -> Lin(me)
  
  -- Successful end to send
  EndSendingLin(me) = endSend.me.SendSuccess -> Lin(me)
  
  -- Lineariser for thread me inside receive.
  ReceivingLin(me) =  
    sync?other:others(me)!me?x -> EndReceivingLin(me, x)
    []
    registerOutSync.me?x -> EndReceivingLin(me, x)
    []
    callMaybeSend.me?index -> beginMaybeSend.me.Alt1.index -> (
      endMaybeSend.me.Alt1.Some?x -> EndReceivingLin(me, x)
      [] endMaybeSend.me.Alt1.None -> ReceivingLin(me)
    )
    [] 
    isClosed.me -> endReceive.me.Closed -> Lin(me)
  
  -- Successful end to receive
  EndReceivingLin(me, x) =  endReceive.me.ReceiveSuccess.x -> Lin(me)

  SendingWithinLin(me, x) = 
    sync.me?other:others(me)!x -> commit.me -> EndSendingWithinLin(me)
    []
    registerInSync.me.x -> commit.me -> EndSendingWithinLin(me)
    []
    callMaybeReceive.me?index!x -> beginMaybeReceive.me.Alt1.index.x -> 
      endMaybeReceive.me.Alt1?res -> 
      (if res then EndSendingWithinLin(me) else SendingWithinLin(me, x))
    []
    isClosed.me -> endSendWithin.me.Closed -> Lin(me)
    []
    timeout.me -> endSendWithin.me.Timeout -> Lin(me)

  -- Successful end to sendWithin
  EndSendingWithinLin(me) = endSendWithin.me.SendSuccess -> Lin(me)
    
  ReceivingWithinLin(me) = 
    sync?other:others(me)!me?x -> EndReceivingWithinLin(me, x)
    []
    registerOutSync.me?x -> EndReceivingWithinLin(me, x)
    []
    callMaybeSend.me?index -> beginMaybeSend.me.Alt1.index -> (
      endMaybeSend.me.Alt1.Some?x -> EndReceivingWithinLin(me, x)
      [] endMaybeSend.me.Alt1.None -> ReceivingWithinLin(me)
    )
    [] 
    isClosed.me -> endReceiveWithin.me.Closed -> Lin(me)
    []
    timeout.me -> endReceiveWithin.me.Timeout -> Lin(me)

  -- Successful end to receiveWithin
  EndReceivingWithinLin(me, x) = 
    endReceiveWithin.me.ReceiveSuccess.x -> Lin(me)

  
  -- Alphabet for Lin(me)
  alphaLin(me) = Union({
    clientInterface(me), 
    {| callMaybeReceive.me, beginMaybeReceive.me, endMaybeReceive.me,
       callMaybeSend.me, beginMaybeSend.me, endMaybeSend.me,
       sync.me, commit.me, registerInSync.me, registerOutSync.me, 
       timeout.me, close.me, isClosed.me  |},
    {| sync.other.me | other <- others(me) |}
  })
  
  -- All the linearisers for channel threads. 
  Lins = || t <- ChanThreads @ [alphaLin(t)] Lin(t)
  
  alphaLins = Union({ alphaLin(t) | t <- ChanThreads })
  
  --------------------------- Main specification
  
  -- A representation of how the alt is registered with the channel.  
  datatype RegStatus = NoReg | InReg.Index | OutReg.Index
  
  -- Is the alt currently registered at the inport or outport?
  isRegIn(InReg._) = true
  isRegIn(_) = false
  
  isRegOut(OutReg._) = true
  isRegOut(_) = false
  
  -- Indexes (at most one) against which the alt is registered.
  regInIndices(InReg.index) = {index}
  regInIndices(_) = {}
  
  regOutIndices(OutReg.index) = {index}
  regOutIndices(_) = {}
  
  -- channel modellingError
  
  -- regStatus records whether and how an alt is registered.
  ChanState :: (RegStatus) -> Proc
  ChanState(regStatus) = 
    let regIns = regInIndices(regStatus)
        regOuts = regOutIndices(regStatus)
    within
  -- Linearisation of register calls.  Note: if there's a pending send, it's
  -- nondeterministic whether the registerIn will synchronise with it.
    regStatus == NoReg & (
      registerInSync?t.x -> ChanState(NoReg) 
      [] registerInWait?index -> ChanState(InReg.index)
      [] registerOutSync?t.x -> ChanState(NoReg)
      [] registerOutWait?index -> ChanState(OutReg.index)
    )
    []
  -- Illegal call of registerIn or registerOut
    regStatus != NoReg & registerError -> STOP
    []   
  -- Deregistration from inport, including if there is no registered port.
    deregisterIn?index:regIns ->  ChanState(NoReg)
    []
    regStatus == NoReg & deregisterIn?index ->  ChanState(NoReg)
    []
  -- Illegal deregistration from inport
    regStatus != NoReg & deregisterInError?index:diff(Index, regIns) -> STOP
    []
  -- Deregistration from outport, including if there is no registered port.
    deregisterOut?index:regOuts -> ChanState(NoReg)
    []
    regStatus == NoReg & deregisterOut?index ->  ChanState(NoReg)
    []
  -- Illegal deregistration from outport
    regStatus != NoReg & deregisterOutError?index:diff(Index, regOuts) -> STOP
    []
  -- Synchronisation between standard send and receive
    sync?t1?t2:others(t1)?x -> ChanState(regStatus)
    []
  -- A thread, having synchronised with either a channel thread or the alt
  -- thread, commits to returning
    commit?_ -> ChanState(regStatus)
    []
  -- Calls to maybeReceive; block other events until the call returns
    callMaybeReceive?t?index:regIns?x -> beginMaybeReceive.t.Alt1.index.x -> 
      endMaybeReceive.t!Alt1?res -> ChanState(NoReg)
    []
  -- Calls to maybeSend; block other events until the call returns
    callMaybeSend?t?index:regOuts -> beginMaybeSend.t.Alt1.index -> 
      endMaybeSend.t.Alt1?res -> ChanState(NoReg)
    -- The initial event of each process in the last two branches is hidden, so
    -- this process may nondeterministically choose to go down that route.
    []
-- IMPROVE: following only if sync impossible? 
    timeout?_ -> ChanState(regStatus)
    []
    close?t -> (
      if regStatus == NoReg then ChanStateClosed
      else     -- inform the registered port
        beginPortClosed.t.Alt1?index:union(regIns,regOuts) ->
        endPortClosed.t.Alt1 -> ChanStateClosed
    )
  
  -- The channel is closed.  
  ChanStateClosed = 
    isClosed?_ -> ChanStateClosed
    [] close?_ -> ChanStateClosed
    [] commit?_ -> ChanStateClosed
    [] timeout?_ -> ChanStateClosed
    [] deregisterIn?_ -> ChanStateClosed
    [] deregisterOut?_ -> ChanStateClosed
  
  alphaChanState = Union({
    AltCallBacks, -- External
    RegLPs, -- Synchronisations with RegIn; registerInSync.t,
	    -- registerOutSync.t also sync with Lin(t)
    {| callMaybeReceive, callMaybeSend, sync, commit, timeout, close, isClosed |}
       -- Events synchonising with Lin(t)s
  })
  
  -- Put the specification together
  ChannelSpec0 = 
    let syncSet = inter(union(alphaChanState, alphaRegLin), alphaLins)
    within
     (ChanState(NoReg) [ alphaChanState || alphaRegLin ] RegLin) 
     [| syncSet |] Lins
     
  -- Error events
  Errors = {| registerError, deregisterInError, deregisterOutError |}
  
exports

  -- Definition of the interface of the channel.  Shared with SyncChan.
  include "ChanInterface.csp"

  -- Specification, with error events visible.
  ChannelSpec = 
    let internals = 
          {| registerInSync, registerInWait, registerOutSync, registerOutWait, 
             deregisterIn, deregisterOut, close, isClosed,
             sync, commit, timeout, callMaybeReceive, callMaybeSend |}
    within ChannelSpec0 \ internals

  -- If an error event happens, allow arbitrary behaviour.  The definitions
  -- are different for the stable failures and failures-divergences models.
  SpecF =  (ChannelSpec [| Errors |> CHAOS(Interface) ) \ Errors
  
  SpecD = (ChannelSpec [| Errors |> DIV ) \ Errors
  
endmodule
  