-- A test on a SyncChan, comparing it to an idealised specification. 

-- Thread identities.  Thread AltThread will run the Alt; other threads will
-- act on channels.
datatype ThreadID = AltThread | T1 | T2  | T3 -- | T4

others(t) = diff(ChanThreads, {t})

ChanThreads =  diff(ThreadID, {AltThread})

-- Identities of channels
datatype ChanID = Chan1

include "Types.csp"

-- Identities of Alts
datatype AltID = Alt1

Strict = true

-- Execute P if Strict is set.  Used for optional assertions. 
IfStrict(P) = if Strict then P else SKIP

include "NewSyncChan.csp" 

-- Max # branches in an alt
size = 2 

-- Possible indices of branches.
Index = {0..size-1}

-- Create channel
instance C1 = SyncChan(ThreadID, AltID, Data, size)

-- A regulator that ensures a channel thread alternates between begins and ends.

Reg(me) = 
  C1::beginSend.me?x -> C1::endSend.me?res -> Reg(me) 
  |~|
  C1::beginReceive.me -> C1::endReceive.me?res -> Reg(me)
  |~|
false & (
  C1::beginSendWithin.me?x -> C1::endSendWithin.me?b -> Reg(me)
  |~|
  C1::beginReceiveWithin.me -> C1::endReceiveWithin.me?ox -> Reg(me)
)
  |~|
false &  C1::beginClose.me -> C1::endClose.me -> Reg(me)
  |~| 
  STOP

-- A regulator that ensures that the alt thread alternates between begin and
-- end events.
AltReg(me, alt) = 
  C1::beginRegisterIn.me.alt$index -> C1::endRegisterIn.me.alt?_ ->
    AltReg(me, alt)
  |~|
  C1::beginDeregisterIn.me.alt$index -> C1::endDeregisterIn.me.alt ->
    AltReg(me, alt)
  |~| 
  STOP

Regs = (||| t <- ChanThreads @ Reg(t))  ||| AltReg(AltThread, Alt1)

-- Events that we don't try to constrain
FreeEvents = 
  {| C1::beginMaybeReceive, C1::endMaybeReceive, 
     C1::beginMaybeSend, C1::endMaybeSend |}

System0 = C1::runWithAndHide(Regs ||| RUN(FreeEvents))

------------------------- Idealised specification


{-
-- channel closing linearization point
channel close: ThreadID . ChanID

channel isClosed: ThreadID . ChanID
-}


-- Macros for set operations
add(set,x) = union(set,{x})
remove(set,x) = diff(set,{x})

--------- Lineariser for registration and deregistration

-- Linearisation points of registration corresponding to a synchronisation,
-- waiting, or an out-of-protocol call.
channel registerInSync : ChanThreads . Data
channel registerInWait : Index 
channel registerError 
-- Linearisation points of deregistration
channel deregisterIn : Index

-- Signal from Spec0 that the Alt has broken the contract.  
channel error

-- Lineariser for registration and deregistration events; but allowing
-- arbitrary behaviour after error.
RegLin = 
  C1::beginRegisterIn.AltThread.Alt1?index -> (
    registerInSync?t?x -> C1::endRegisterIn.AltThread.Alt1.RegisterInSuccess.x ->
    RegLin
    []
    registerInWait.index -> C1::endRegisterIn.AltThread.Alt1.RegisterInWaiting ->
    RegLin
    []
    registerError -> STOP
  )
  |~|
  C1::beginDeregisterIn.AltThread.Alt1?index -> deregisterIn.index -> (
    C1::endDeregisterIn.AltThread.Alt1 -> RegLin
    []
    error -> STOP
  )
  |~|
  STOP

-- alphaRegLinExt = {|
--   C1::beginRegisterIn, C1::endRegisterIn,
--   C1::beginDeregisterIn, C1::endDeregisterIn
-- |}
alphaRegLin = {|
  C1::beginRegisterIn, C1::endRegisterIn, 
  registerInSync, registerInWait, registerError,
  C1::beginDeregisterIn, C1::endDeregisterIn, deregisterIn, error
|}

------------ Lineariser for channel thread ops

-- In sync and altSync events, the sender comes first

-- synchronsation between a sender and receiver
channel sync : ChanThreads . ChanThreads . Data

Lin(me) = 
  C1::beginSend.me?x -> SendingLin(me, x)
  |~|
  C1::beginReceive.me -> ReceivingLin(me)
  |~|
  STOP

SendingLin(me, x) = 
  callMaybeReceive.me?index!x -> C1::beginMaybeReceive.me.Alt1.index.x -> 
  C1::endMaybeReceive.me.Alt1?res -> (
    if res then C1::endSend.me.SendSuccess -> Lin(me)
    else SendingLin(me, x)
  )
  []
  sync.me?other:others(me)!x -> C1::endSend.me.SendSuccess -> Lin(me)
  []
  registerInSync.me.x -> C1::endSend.me.SendSuccess -> Lin(me)

ReceivingLin(me) =  
  sync?other:others(me)!me?x -> 
  C1::endReceive.me.ReceiveSuccess.x -> Lin(me)
  
alphaLin(me) = union(
  {| C1::beginSend.me, C1::endSend.me, C1::beginReceive.me, C1::endReceive.me,
     callMaybeReceive.me, C1::beginMaybeReceive.me, C1::endMaybeReceive.me,
     sync.me, registerInSync.me  |},
  {| sync.other.me | other <- others(me) |}
)

Lins = || t <- ChanThreads @ [alphaLin(t)] Lin(t)

alphaLins = Union({ alphaLin(t) | t <- ChanThreads })

--------------------------- Main specification

-- A representation of how the alt is registered with the channel.  
datatype RegStatus = NoReg | InReg.Index | OutReg.Index.Data 

-- Is there an alt currently registered at the InPort?
isRegIn(InReg._) = true
isRegIn(_) = false

-- Nondeterministic choice over a set of processes
-- Choose(S) = |~| P: S @ P



-- The channel chooses to call maybeReceive by a particular thread.
channel callMaybeReceive : ChanThreads . Index . Data

-- Synchronisation between threads in Alt and channel, passing data value.
--channel altSync : ThreadID . ThreadID . ChanID . Data

-- threadOf(C1::endSend.t._) = t
-- threadOf(C1::endReceive.t._) = t

channel modellingError

-- regStatus records whether and how an alt is registered.
Spec1 :: (RegStatus) -> Proc
Spec1(regStatus) = 
-- Linearisation of registerIn calls.  Note: if there's a pending send, it's
-- nondeterministic whether the registerIn will synchronise with it.
  regStatus == NoReg & (
    registerInWait?index -> Spec1(InReg.index)
    []
    registerInSync?t.x -> Spec1(NoReg) 
  )
  []
-- Illegal call of registerIn
  regStatus != NoReg & registerError -> STOP
  [] 
-- Deregistration from inport.
  deregisterIn?index -> (
    if regStatus == (InReg.index) then Spec1(NoReg) else error -> STOP 
  )
  []
-- Synchronisation between standard send and receive
  sync?t1?t2:others(t1)?x -> Spec1(regStatus)
  []
-- Calls to maybeReceive
  isRegIn(regStatus) & (
    let InReg.index = regStatus within
    callMaybeReceive?t!index?x -> C1::beginMaybeReceive.t.Alt1.index.x -> 
    C1::endMaybeReceive.t!Alt1?res -> Spec1(NoReg)
  )
  -- The initial event of each process in the last two branches is hidden, so
  -- this process may nondeterministically choose to go down that route.

alphaSpec = {|
  C1::beginMaybeReceive, C1::endMaybeReceive,
  sync, callMaybeReceive, registerInSync, registerInWait, registerError, 
  deregisterIn, error, modellingError
|}

-- Put the specification together
Spec2 = 
  let syncSet = inter(union(alphaSpec, alphaRegLin), alphaLins) within
  ((Spec1(NoReg) [ alphaSpec || alphaRegLin ] RegLin) [| syncSet |] Lins) 
   \ {| registerInSync, registerInWait, deregisterIn, sync, callMaybeReceive |}

-- Allow arbitrary behaviour after an error event; first for stable failures.
SpecF = 
  (Spec2 [| {error,registerError} |> CHAOS(C1::Interface) )
  \ {| registerError, error |}

-- Now for FD model.
SpecD = 
  (Spec2 [| {error,registerError} |> DIV )
  \ {| registerError, error |}

assert SpecF [T= System0

assert SpecF [F= System0

assert SpecD [FD= System0

transparent normal
--assert CHAOS(Events) [F= normal(Spec)